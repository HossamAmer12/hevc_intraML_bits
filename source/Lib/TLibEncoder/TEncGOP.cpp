/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2014, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncGOP.cpp
 \brief    GOP encoder class
 */

#include <list>
#include <algorithm>
#include <functional>

#include "TEncTop.h"
#include "TEncGOP.h"
#include "TEncAnalyze.h"
#include "libmd5/MD5.h"
#include "TLibCommon/SEI.h"
#include "TLibCommon/NAL.h"
#include "NALwrite.h"
#include <time.h>
#include <math.h>

using namespace std;



#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
Bool g_bFinalEncode = false;
#endif

//! \ingroup TLibEncoder
//! \{

// ====================================================================================================================
// Constructor / destructor / initialization / destroy
// ====================================================================================================================
Int getLSB(Int poc, Int maxLSB)
{
    if (poc >= 0)
    {
        return poc % maxLSB;
    }
    else
    {
        return (maxLSB - ((-poc) % maxLSB)) % maxLSB;
    }
}

TEncGOP::TEncGOP()
{
    
    // Hossam: Look Ahead
    general_GOP_id = 0;
    pocCurrFactor = 0;
    actual_GOP_id = 0;
    pocCurrFactorActual = 0;
    m_iNumPicCodedActual = 0;
    
    // Hossam: look ahead -- progress in sliding window
    progress_in_sliding_window = 0;
    sliding_window_length = 0;
    encoding_actual_progress = 0;
    
    // Hossam: p frames without lookahead
    
#if IS_ADAPTIVE_PROPAGATION_LENGTH
    
    // Set the Propogation length
    setAdaptivePropagationLength(EPSILON_PROPAGATION_LENTGH);
    
    
    start_prop_window = 0;
    end_prop_window   = 4 + g_pPropLength;

#else
    start_prop_window = 0;
    end_prop_window   = 8;
#endif
    
    
#if IS_INTER_DEP_MULTIPLE_REF
    start_prop_window_mu = 1;
    end_prop_window_mu = 13;
#else
    start_prop_window_mu = 3;
    end_prop_window_mu = 7;
#endif
    
    
    m_iLastIDR            = 0;
    m_iGopSize            = 0;
    m_iNumPicCoded        = 0; //Niko
    m_bFirst              = true;
#if ALLOW_RECOVERY_POINT_AS_RAP
    m_iLastRecoveryPicPOC = 0;
#endif
    
    m_pcCfg               = NULL;
    m_pcSliceEncoder      = NULL;
    m_pcListPic           = NULL;
    
    m_pcEntropyCoder      = NULL;
    m_pcCavlcCoder        = NULL;
    m_pcSbacCoder         = NULL;
    m_pcBinCABAC          = NULL;
    
    m_bSeqFirst           = true;
    
    // Hossam: look ahead
    m_bSeqFirstLookAhead  = true;
    
    m_bRefreshPending     = 0;
    m_pocCRA            = 0;
    m_numLongTermRefPicSPS = 0;
    ::memset(m_ltRefPicPocLsbSps, 0, sizeof(m_ltRefPicPocLsbSps));
    ::memset(m_ltRefPicUsedByCurrPicFlag, 0, sizeof(m_ltRefPicUsedByCurrPicFlag));
    m_cpbRemovalDelay   = 0;
    m_lastBPSEI         = 0;
    xResetNonNestedSEIPresentFlags();
    xResetNestedSEIPresentFlags();
#if FIX1172
    m_associatedIRAPType = NAL_UNIT_CODED_SLICE_IDR_N_LP;
    m_associatedIRAPPOC  = 0;
#endif
    return;
}

TEncGOP::~TEncGOP()
{
}

/** Create list to contain pointers to LCU start addresses of slice.
 */
Void  TEncGOP::create()
{
    m_bLongtermTestPictureHasBeenCoded = 0;
    m_bLongtermTestPictureHasBeenCoded2 = 0;
    
    
}

Void  TEncGOP::destroy()
{
}

Void TEncGOP::init ( TEncTop* pcTEncTop )
{
    m_pcEncTop     = pcTEncTop;
    m_pcCfg                = pcTEncTop;
    m_pcSliceEncoder       = pcTEncTop->getSliceEncoder();
    m_pcListPic            = pcTEncTop->getListPic();
    
    m_pcEntropyCoder       = pcTEncTop->getEntropyCoder();
    m_pcCavlcCoder         = pcTEncTop->getCavlcCoder();
    m_pcSbacCoder          = pcTEncTop->getSbacCoder();
    m_pcBinCABAC           = pcTEncTop->getBinCABAC();
    m_pcLoopFilter         = pcTEncTop->getLoopFilter();
    m_pcBitCounter         = pcTEncTop->getBitCounter();
    
    m_pcSAO                = pcTEncTop->getSAO();
    m_pcRateCtrl           = pcTEncTop->getRateCtrl();
    m_lastBPSEI          = 0;
    m_totalCoded         = 0;
    
    // Hossam: GOP_STR_TYPE
    //    m_gop_str_type = m_pcCfg -> getGOPStrType();
    //    m_inputFileName = m_pcCfg -> getInputFileName();
    
    // Hossam: Init the mu method on
    isMuMethodON = true;
    
    // Hossam: init the epsilon method on
    isEpsilonMethodON = true;
    
}

SEIActiveParameterSets* TEncGOP::xCreateSEIActiveParameterSets (TComSPS *sps)
{
    SEIActiveParameterSets *seiActiveParameterSets = new SEIActiveParameterSets();
    seiActiveParameterSets->activeVPSId = m_pcCfg->getVPS()->getVPSId();
    seiActiveParameterSets->m_selfContainedCvsFlag = false;
    seiActiveParameterSets->m_noParameterSetUpdateFlag = false;
    seiActiveParameterSets->numSpsIdsMinus1 = 0;
    seiActiveParameterSets->activeSeqParameterSetId.resize(seiActiveParameterSets->numSpsIdsMinus1 + 1);
    seiActiveParameterSets->activeSeqParameterSetId[0] = sps->getSPSId();
    return seiActiveParameterSets;
}

SEIFramePacking* TEncGOP::xCreateSEIFramePacking()
{
    SEIFramePacking *seiFramePacking = new SEIFramePacking();
    seiFramePacking->m_arrangementId = m_pcCfg->getFramePackingArrangementSEIId();
    seiFramePacking->m_arrangementCancelFlag = 0;
    seiFramePacking->m_arrangementType = m_pcCfg->getFramePackingArrangementSEIType();
    assert((seiFramePacking->m_arrangementType > 2) && (seiFramePacking->m_arrangementType < 6) );
    seiFramePacking->m_quincunxSamplingFlag = m_pcCfg->getFramePackingArrangementSEIQuincunx();
    seiFramePacking->m_contentInterpretationType = m_pcCfg->getFramePackingArrangementSEIInterpretation();
    seiFramePacking->m_spatialFlippingFlag = 0;
    seiFramePacking->m_frame0FlippedFlag = 0;
    seiFramePacking->m_fieldViewsFlag = (seiFramePacking->m_arrangementType == 2);
    seiFramePacking->m_currentFrameIsFrame0Flag = ((seiFramePacking->m_arrangementType == 5) && (m_iNumPicCoded&1));
    seiFramePacking->m_frame0SelfContainedFlag = 0;
    seiFramePacking->m_frame1SelfContainedFlag = 0;
    seiFramePacking->m_frame0GridPositionX = 0;
    seiFramePacking->m_frame0GridPositionY = 0;
    seiFramePacking->m_frame1GridPositionX = 0;
    seiFramePacking->m_frame1GridPositionY = 0;
    seiFramePacking->m_arrangementReservedByte = 0;
    seiFramePacking->m_arrangementPersistenceFlag = true;
    seiFramePacking->m_upsampledAspectRatio = 0;
    return seiFramePacking;
}

SEISegmentedRectFramePacking* TEncGOP::xCreateSEISegmentedRectFramePacking()
{
    SEISegmentedRectFramePacking *seiSegmentedRectFramePacking = new SEISegmentedRectFramePacking();
    seiSegmentedRectFramePacking->m_arrangementCancelFlag = m_pcCfg->getSegmentedRectFramePackingArrangementSEICancel();
    seiSegmentedRectFramePacking->m_contentInterpretationType = m_pcCfg->getSegmentedRectFramePackingArrangementSEIType();
    seiSegmentedRectFramePacking->m_arrangementPersistenceFlag = m_pcCfg->getSegmentedRectFramePackingArrangementSEIPersistence();
    return seiSegmentedRectFramePacking;
}

SEIDisplayOrientation* TEncGOP::xCreateSEIDisplayOrientation()
{
    SEIDisplayOrientation *seiDisplayOrientation = new SEIDisplayOrientation();
    seiDisplayOrientation->cancelFlag = false;
    seiDisplayOrientation->horFlip = false;
    seiDisplayOrientation->verFlip = false;
    seiDisplayOrientation->anticlockwiseRotation = m_pcCfg->getDisplayOrientationSEIAngle();
    return seiDisplayOrientation;
}
SEIToneMappingInfo*  TEncGOP::xCreateSEIToneMappingInfo()
{
    SEIToneMappingInfo *seiToneMappingInfo = new SEIToneMappingInfo();
    seiToneMappingInfo->m_toneMapId = m_pcCfg->getTMISEIToneMapId();
    seiToneMappingInfo->m_toneMapCancelFlag = m_pcCfg->getTMISEIToneMapCancelFlag();
    seiToneMappingInfo->m_toneMapPersistenceFlag = m_pcCfg->getTMISEIToneMapPersistenceFlag();
    
    seiToneMappingInfo->m_codedDataBitDepth = m_pcCfg->getTMISEICodedDataBitDepth();
    assert(seiToneMappingInfo->m_codedDataBitDepth >= 8 && seiToneMappingInfo->m_codedDataBitDepth <= 14);
    seiToneMappingInfo->m_targetBitDepth = m_pcCfg->getTMISEITargetBitDepth();
    assert(seiToneMappingInfo->m_targetBitDepth >= 1 && seiToneMappingInfo->m_targetBitDepth <= 17);
    seiToneMappingInfo->m_modelId = m_pcCfg->getTMISEIModelID();
    assert(seiToneMappingInfo->m_modelId >=0 &&seiToneMappingInfo->m_modelId<=4);
    
    switch( seiToneMappingInfo->m_modelId)
    {
        case 0:
        {
            seiToneMappingInfo->m_minValue = m_pcCfg->getTMISEIMinValue();
            seiToneMappingInfo->m_maxValue = m_pcCfg->getTMISEIMaxValue();
            break;
        }
        case 1:
        {
            seiToneMappingInfo->m_sigmoidMidpoint = m_pcCfg->getTMISEISigmoidMidpoint();
            seiToneMappingInfo->m_sigmoidWidth = m_pcCfg->getTMISEISigmoidWidth();
            break;
        }
        case 2:
        {
            UInt num = 1u<<(seiToneMappingInfo->m_targetBitDepth);
            seiToneMappingInfo->m_startOfCodedInterval.resize(num);
            Int* ptmp = m_pcCfg->getTMISEIStartOfCodedInterva();
            if(ptmp)
            {
                for(Int i=0; i<num;i++)
                {
                    seiToneMappingInfo->m_startOfCodedInterval[i] = ptmp[i];
                }
            }
            break;
        }
        case 3:
        {
            seiToneMappingInfo->m_numPivots = m_pcCfg->getTMISEINumPivots();
            seiToneMappingInfo->m_codedPivotValue.resize(seiToneMappingInfo->m_numPivots);
            seiToneMappingInfo->m_targetPivotValue.resize(seiToneMappingInfo->m_numPivots);
            Int* ptmpcoded = m_pcCfg->getTMISEICodedPivotValue();
            Int* ptmptarget = m_pcCfg->getTMISEITargetPivotValue();
            if(ptmpcoded&&ptmptarget)
            {
                for(Int i=0; i<(seiToneMappingInfo->m_numPivots);i++)
                {
                    seiToneMappingInfo->m_codedPivotValue[i]=ptmpcoded[i];
                    seiToneMappingInfo->m_targetPivotValue[i]=ptmptarget[i];
                }
            }
            break;
        }
        case 4:
        {
            seiToneMappingInfo->m_cameraIsoSpeedIdc = m_pcCfg->getTMISEICameraIsoSpeedIdc();
            seiToneMappingInfo->m_cameraIsoSpeedValue = m_pcCfg->getTMISEICameraIsoSpeedValue();
            assert( seiToneMappingInfo->m_cameraIsoSpeedValue !=0 );
            seiToneMappingInfo->m_exposureIndexIdc = m_pcCfg->getTMISEIExposurIndexIdc();
            seiToneMappingInfo->m_exposureIndexValue = m_pcCfg->getTMISEIExposurIndexValue();
            assert( seiToneMappingInfo->m_exposureIndexValue !=0 );
            seiToneMappingInfo->m_exposureCompensationValueSignFlag = m_pcCfg->getTMISEIExposureCompensationValueSignFlag();
            seiToneMappingInfo->m_exposureCompensationValueNumerator = m_pcCfg->getTMISEIExposureCompensationValueNumerator();
            seiToneMappingInfo->m_exposureCompensationValueDenomIdc = m_pcCfg->getTMISEIExposureCompensationValueDenomIdc();
            seiToneMappingInfo->m_refScreenLuminanceWhite = m_pcCfg->getTMISEIRefScreenLuminanceWhite();
            seiToneMappingInfo->m_extendedRangeWhiteLevel = m_pcCfg->getTMISEIExtendedRangeWhiteLevel();
            assert( seiToneMappingInfo->m_extendedRangeWhiteLevel >= 100 );
            seiToneMappingInfo->m_nominalBlackLevelLumaCodeValue = m_pcCfg->getTMISEINominalBlackLevelLumaCodeValue();
            seiToneMappingInfo->m_nominalWhiteLevelLumaCodeValue = m_pcCfg->getTMISEINominalWhiteLevelLumaCodeValue();
            assert( seiToneMappingInfo->m_nominalWhiteLevelLumaCodeValue > seiToneMappingInfo->m_nominalBlackLevelLumaCodeValue );
            seiToneMappingInfo->m_extendedWhiteLevelLumaCodeValue = m_pcCfg->getTMISEIExtendedWhiteLevelLumaCodeValue();
            assert( seiToneMappingInfo->m_extendedWhiteLevelLumaCodeValue >= seiToneMappingInfo->m_nominalWhiteLevelLumaCodeValue );
            break;
        }
        default:
        {
            assert(!"Undefined SEIToneMapModelId");
            break;
        }
    }
    return seiToneMappingInfo;
}

SEITempMotionConstrainedTileSets* TEncGOP::xCreateSEITempMotionConstrainedTileSets ()
{
    TComPPS *pps = m_pcEncTop->getPPS();
    SEITempMotionConstrainedTileSets *sei = new SEITempMotionConstrainedTileSets();
    if(pps->getTilesEnabledFlag())
    {
        sei->m_mc_all_tiles_exact_sample_value_match_flag = false;
        sei->m_each_tile_one_tile_set_flag                = false;
        sei->m_limited_tile_set_display_flag              = false;
        sei->setNumberOfTileSets((pps->getNumTileColumnsMinus1() + 1) * (pps->getTileNumRowsMinus1() + 1));
        
        for(Int i=0; i < sei->getNumberOfTileSets(); i++)
        {
            sei->tileSetData(i).m_mcts_id = i;  //depends the application;
            sei->tileSetData(i).setNumberOfTileRects(1);
            
            for(Int j=0; j<sei->tileSetData(i).getNumberOfTileRects(); j++)
            {
                sei->tileSetData(i).topLeftTileIndex(j)     = i+j;
                sei->tileSetData(i).bottomRightTileIndex(j) = i+j;
            }
            
            sei->tileSetData(i).m_exact_sample_value_match_flag    = false;
            sei->tileSetData(i).m_mcts_tier_level_idc_present_flag = false;
        }
    }
    else
    {
        assert(!"Tile is not enabled");
    }
    return sei;
}

SEIKneeFunctionInfo* TEncGOP::xCreateSEIKneeFunctionInfo()
{
    SEIKneeFunctionInfo *seiKneeFunctionInfo = new SEIKneeFunctionInfo();
    seiKneeFunctionInfo->m_kneeId = m_pcCfg->getKneeSEIId();
    seiKneeFunctionInfo->m_kneeCancelFlag = m_pcCfg->getKneeSEICancelFlag();
    if ( !seiKneeFunctionInfo->m_kneeCancelFlag )
    {
        seiKneeFunctionInfo->m_kneePersistenceFlag = m_pcCfg->getKneeSEIPersistenceFlag();
        seiKneeFunctionInfo->m_kneeMappingFlag = m_pcCfg->getKneeSEIMappingFlag();
        seiKneeFunctionInfo->m_kneeInputDrange = m_pcCfg->getKneeSEIInputDrange();
        seiKneeFunctionInfo->m_kneeInputDispLuminance = m_pcCfg->getKneeSEIInputDispLuminance();
        seiKneeFunctionInfo->m_kneeOutputDrange = m_pcCfg->getKneeSEIOutputDrange();
        seiKneeFunctionInfo->m_kneeOutputDispLuminance = m_pcCfg->getKneeSEIOutputDispLuminance();
        
        seiKneeFunctionInfo->m_kneeNumKneePointsMinus1 = m_pcCfg->getKneeSEINumKneePointsMinus1();
        Int* piInputKneePoint  = m_pcCfg->getKneeSEIInputKneePoint();
        Int* piOutputKneePoint = m_pcCfg->getKneeSEIOutputKneePoint();
        if(piInputKneePoint&&piOutputKneePoint)
        {
            seiKneeFunctionInfo->m_kneeInputKneePoint.resize(seiKneeFunctionInfo->m_kneeNumKneePointsMinus1+1);
            seiKneeFunctionInfo->m_kneeOutputKneePoint.resize(seiKneeFunctionInfo->m_kneeNumKneePointsMinus1+1);
            for(Int i=0; i<=seiKneeFunctionInfo->m_kneeNumKneePointsMinus1; i++)
            {
                seiKneeFunctionInfo->m_kneeInputKneePoint[i] = piInputKneePoint[i];
                seiKneeFunctionInfo->m_kneeOutputKneePoint[i] = piOutputKneePoint[i];
            }
        }
    }
    return seiKneeFunctionInfo;
}

SEIChromaSamplingFilterHint* TEncGOP::xCreateSEIChromaSamplingFilterHint(Bool bChromaLocInfoPresent, Int iHorFilterIndex, Int iVerFilterIndex)
{
    SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = new SEIChromaSamplingFilterHint();
    seiChromaSamplingFilterHint->m_verChromaFilterIdc = iVerFilterIndex;
    seiChromaSamplingFilterHint->m_horChromaFilterIdc = iHorFilterIndex;
    seiChromaSamplingFilterHint->m_verFilteringProcessFlag = 1;
    seiChromaSamplingFilterHint->m_targetFormatIdc = 3;
    seiChromaSamplingFilterHint->m_perfectReconstructionFlag = false;
    if(seiChromaSamplingFilterHint->m_verChromaFilterIdc == 1)
    {
        seiChromaSamplingFilterHint->m_numVerticalFilters = 1;
        seiChromaSamplingFilterHint->m_verTapLengthMinus1 = (Int*)malloc(seiChromaSamplingFilterHint->m_numVerticalFilters * sizeof(Int));
        seiChromaSamplingFilterHint->m_verFilterCoeff =    (Int**)malloc(seiChromaSamplingFilterHint->m_numVerticalFilters * sizeof(Int*));
        for(Int i = 0; i < seiChromaSamplingFilterHint->m_numVerticalFilters; i ++)
        {
            seiChromaSamplingFilterHint->m_verTapLengthMinus1[i] = 0;
            seiChromaSamplingFilterHint->m_verFilterCoeff[i] = (Int*)malloc(seiChromaSamplingFilterHint->m_verTapLengthMinus1[i] * sizeof(Int));
            for(Int j = 0; j < seiChromaSamplingFilterHint->m_verTapLengthMinus1[i]; j ++)
            {
                seiChromaSamplingFilterHint->m_verFilterCoeff[i][j] = 0;
            }
        }
    }
    else
    {
        seiChromaSamplingFilterHint->m_numVerticalFilters = 0;
        seiChromaSamplingFilterHint->m_verTapLengthMinus1 = NULL;
        seiChromaSamplingFilterHint->m_verFilterCoeff = NULL;
    }
    if(seiChromaSamplingFilterHint->m_horChromaFilterIdc == 1)
    {
        seiChromaSamplingFilterHint->m_numHorizontalFilters = 1;
        seiChromaSamplingFilterHint->m_horTapLengthMinus1 = (Int*)malloc(seiChromaSamplingFilterHint->m_numHorizontalFilters * sizeof(Int));
        seiChromaSamplingFilterHint->m_horFilterCoeff = (Int**)malloc(seiChromaSamplingFilterHint->m_numHorizontalFilters * sizeof(Int*));
        for(Int i = 0; i < seiChromaSamplingFilterHint->m_numHorizontalFilters; i ++)
        {
            seiChromaSamplingFilterHint->m_horTapLengthMinus1[i] = 0;
            seiChromaSamplingFilterHint->m_horFilterCoeff[i] = (Int*)malloc(seiChromaSamplingFilterHint->m_horTapLengthMinus1[i] * sizeof(Int));
            for(Int j = 0; j < seiChromaSamplingFilterHint->m_horTapLengthMinus1[i]; j ++)
            {
                seiChromaSamplingFilterHint->m_horFilterCoeff[i][j] = 0;
            }
        }
    }
    else
    {
        seiChromaSamplingFilterHint->m_numHorizontalFilters = 0;
        seiChromaSamplingFilterHint->m_horTapLengthMinus1 = NULL;
        seiChromaSamplingFilterHint->m_horFilterCoeff = NULL;
    }
    return seiChromaSamplingFilterHint;
}

Void TEncGOP::xCreateLeadingSEIMessages (/*SEIMessages seiMessages,*/ AccessUnit &accessUnit, TComSPS *sps)
{
    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
    
    if(m_pcCfg->getActiveParameterSetsSEIEnabled())
    {
        SEIActiveParameterSets *sei = xCreateSEIActiveParameterSets (sps);
        
        //nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
        m_activeParameterSetSEIPresentInAU = true;
    }
    
    if(m_pcCfg->getFramePackingArrangementSEIEnabled())
    {
        SEIFramePacking *sei = xCreateSEIFramePacking ();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
    }
    if(m_pcCfg->getSegmentedRectFramePackingArrangementSEIEnabled())
    {
        SEISegmentedRectFramePacking *sei = xCreateSEISegmentedRectFramePacking ();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
    }
    if (m_pcCfg->getDisplayOrientationSEIAngle())
    {
        SEIDisplayOrientation *sei = xCreateSEIDisplayOrientation();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
    }
    
    if(m_pcCfg->getToneMappingInfoSEIEnabled())
    {
        SEIToneMappingInfo *sei = xCreateSEIToneMappingInfo ();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
    }
    
    if(m_pcCfg->getTMCTSSEIEnabled())
    {
        SEITempMotionConstrainedTileSets *sei_tmcts = xCreateSEITempMotionConstrainedTileSets ();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei_tmcts, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei_tmcts;
    }
    
    if(m_pcCfg->getTimeCodeSEIEnabled())
    {
        SEITimeCode sei_time_code;
        //  Set data as per command line options
        sei_time_code.numClockTs = m_pcCfg->getNumberOfTimesets();
        for(Int i = 0; i < sei_time_code.numClockTs; i++)
            sei_time_code.timeSetArray[i] = m_pcCfg->getTimeSet(i);
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_time_code, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
    }
    
    if(m_pcCfg->getKneeSEIEnabled())
    {
        SEIKneeFunctionInfo *sei = xCreateSEIKneeFunctionInfo();
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, *sei, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        delete sei;
    }
    
    if(m_pcCfg->getMasteringDisplaySEI().colourVolumeSEIEnabled)
    {
        const TComSEIMasteringDisplay &seiCfg=m_pcCfg->getMasteringDisplaySEI();
        SEIMasteringDisplayColourVolume mdcv;
        mdcv.values = seiCfg;
        
        nalu = NALUnit(NAL_UNIT_PREFIX_SEI);
        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
        m_seiWriter.writeSEImessage(nalu.m_Bitstream, mdcv, sps);
        writeRBSPTrailingBits(nalu.m_Bitstream);
        accessUnit.push_back(new NALUnitEBSP(nalu));
        
    }
}

// ====================================================================================================================
// Public member functions
// ====================================================================================================================

static Bool isSceneChange = false;
static Bool isSmooth      = false;
static Int referenceSlice = -1;
Void TEncGOP::compressGOP( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic,
                          TComList<TComPicYuv*>& rcListPicYuvRecOut, std::list<AccessUnit>& accessUnitsInGOP,
                          Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE )
{
    
    //    cout << "Yang: TEncGOP: compressGOP: Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
//    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //      cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        
        
//        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
//        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
//            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            
            // reset the select attempt process
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
        }
        
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
       m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
//        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
//        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
//        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));

        
        // Hossam: XXXXX I think setList1toList can be removed!
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();

        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================

        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
//        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
//         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;

//        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
//        
//        // HARD CODE
//        if (pocCurr == 59) {
//            isSmooth = true;
//        }
//        
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
//        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
//
//        }
        
        if(isSceneChange)
        {
            
//            cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
//            m_iLastRecoveryPicPOC = pcSlice->getPOC();
//            
//            // Reset the select flags in order to avoid the mismatch in the Select process later on
//            m_pcEncTop->resetSelectAttemptProcess();
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
//            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
//                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
//            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
//                m_pcEncTop->resetSelectAttemptProcess();
                
            }
           else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;

                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
             
            }
            
        }
        
//        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
//            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            
            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );


            // Send the isSceneChange
            
//        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                           m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
    
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
//            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
             m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
//            // Hossam: Set the new state accordingly
//            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
//           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());

            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;

#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else   
             // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
//                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
                       
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
//            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;

        
        // Hossam: SC should be IRAP  XXXXXX
//        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
//        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
//        
//        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
//        
//        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
//        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
//        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
//        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
//
        
//        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
//            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        // Hossam: I guess just for filtering
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
}

// Passant Mahmoud --
// July 11th -- compress for the bench marks
Void TEncGOP::compressGOPNewBench(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //      cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else

        // Hossam: 10/06/2016 --> This one is the used one
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
        // ending SC time + total SC time
        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
//        cout << "Result time: " << dResult << ", (clock()-lBefore) " << (clock()-lBefore)  << endl;
        g_totalSCTime += dResult;
        
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
// Passant Mahmoud -- Only if it's a scene change reencode
//#if IS_YAO_SCD || IS_SASTRE_SCD
     if (isSceneChange || pcSlice->getPOC() == 0) {
            while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
            {
                pcSlice->setNextSlice       ( false );
                pcSlice->setNextSliceSegment( false );
                assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
                m_pcSliceEncoder->precompressSlice( pcPic );
                
                // Hossam: Compress Slice
                m_pcSliceEncoder->compressSlice   ( pcPic );
                //            cout << "Ack Done with Compress Slice " << endl;
                
                Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
                if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
                {
                    startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                    // Reconstruction slice
                    m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                    startCUAddrSliceIdx++;
                    // Dependent slice
                    if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                    {
                        m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    if (startCUAddrSlice < uiRealEndAddress)
                    {
                        pcPic->allocateNewSlice();
                        pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                        m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                        pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                        pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                        pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                        pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                        pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                        pcSlice->setSliceBits(0);
                        uiNumSlices ++;
                    }
                }
                else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
                {
                    startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                    startCUAddrSliceSegmentIdx++;
                    pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
                }
                else
                {
                    startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                    startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                }
                
                nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
            }
            
        }// end skip encoding
        // Moved it from up there to here
        // Hossam: Reset the Scene change flag
        isSceneChange = false;

        
// Update the intra count of the previous frame for sastre method
#if IS_SASTRE_SCD
        m_pcSliceEncoder->xExtractSliceInfo(pcPic);
        // Update the weighted average! Now, the last encoded frame is (k+1)
        m_pcSliceEncoder-> sastre_intra_count_tillK = pcSlice->intra_modes;
#endif
//#endif
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
}


// Passant Mahmoud --
// July 11th -- compress for the bench marks (INCOMPLETE -- Will use SC functions for mu and epsilon) Feb 27, 2018
Void TEncGOP::compressGOPNewBenchInterSC(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //      cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        
// for all bench marks get the original sigma squared
#if IS_YAO_SCD || IS_DING_SCD || IS_SASTRE_SCD
        // Get the original sigma squared
        //        Bool mock_sc = m_pcEncTop->getSceneChangeCoder() -> isSceneChangeInter(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        //        cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
        //        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal());
        
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(),pcSlice, rcListPic, pcPic));
        
        cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
#endif
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // Hossam: 10/06/2016 --> This one is the used one
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        

        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        cout << "Result time: " << dResult << ", (clock()-lBefore) " << (clock()-lBefore)  << endl;
        g_totalSCTime += dResult;
        
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
            //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        
         cout << " Output :62L: " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        cout << " Output :62Llll: " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;

        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        cout << " Output :62L222: " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        
        cout << " Output :62L333: " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        cout << " Output 232323: " << isSceneChange << ", " << pcSlice->getPOC() << endl;
//        isSceneChange = true;
        
        // Passant Mahmoud -- Only if it's a scene change reencode
        //#if IS_YAO_SCD || IS_SASTRE_SCD
        if (isSceneChange || pcSlice->getPOC() == 0) {
             cout << " Output 232323: " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
            while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
            {
                pcSlice->setNextSlice       ( false );
                pcSlice->setNextSliceSegment( false );
                assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
                m_pcSliceEncoder->precompressSlice( pcPic );
                
                
                 cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
                // Hossam: Compress Slice
                m_pcSliceEncoder->compressSlice   ( pcPic );
                            cout << "Ack Done with Compress Slice " << endl;
                
                Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
                if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
                {
                    startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                    // Reconstruction slice
                    m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                    startCUAddrSliceIdx++;
                    // Dependent slice
                    if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                    {
                        m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    if (startCUAddrSlice < uiRealEndAddress)
                    {
                        pcPic->allocateNewSlice();
                        pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                        m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                        pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                        pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                        pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                        pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                        pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                        pcSlice->setSliceBits(0);
                        uiNumSlices ++;
                    }
                }
                else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
                {
                    startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                    startCUAddrSliceSegmentIdx++;
                    pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
                }
                else
                {
                    startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                    startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                }
                
                nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
            }
            
        }// end skip encoding
        // Moved it from up there to here
        // Hossam: Reset the Scene change flag
        isSceneChange = false;
        
        
        // Update the intra count of the previous frame for sastre method
#if IS_SASTRE_SCD
        m_pcSliceEncoder->xExtractSliceInfo(pcPic);
        // Update the weighted average! Now, the last encoded frame is (k+1)
        m_pcSliceEncoder-> sastre_intra_count_tillK = pcSlice->intra_modes;
#endif
        //#endif
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
}

// Hossam be y2ool:
// Hossam: I produced this method to send the buffer -- it's now used here 18/05/2016
//  rcListPic: Original frames I guess
//  rcListPicYuvRecOut: Reconstructed frames Out, list of reconstruction YUV files coming from the very top encoder main, sent by reference
//  rcListPicYuvOrg: My list

Void TEncGOP::compressGOPNew(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
//Void TEncGOP:: compressGOPNew ( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRec,
//                                     std::list<AccessUnit>& accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE, TComList<TComPicYuv*>& rcListPicYuvOrg )
{
    
//        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
//    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
//    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
//              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;

        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
//        TComPic*        pcPicOrg;
//        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
// Hossam: Scene Change ORG
//        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
// You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
     m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
    m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
//        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
//        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
//        
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif

#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            

            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);


            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
//        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
//        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        

        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        //        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        

//#if SC_FROM_RECONS
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
//#else

        // Hossam: 10/06/2016 --> This one is the used one
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);

        // This part is from July 11th
//#if IS_YAO_SCD
//            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//#elif IS_DING_SCD
//        
//        // starting SC time
//        Double dResult;
//        clock_t lBefore = clock();
//        
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//
//        // ending SC time + total SC time
//        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
//        g_totalSCTime += dResult;
//        
//#elif IS_SASTRE_SCD
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//#else
//        
//        // starting SC time
//        Double dResult;
//        clock_t lBefore = clock();
//        // Hossam: 10/06/2016 --> This one is the used one
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//        
//        // ending SC time
//        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
////        printf("\n Total SC Time: %12.3f sec.\n", dResult);
//        
//        // Accumlate the total SC Time
//        g_totalSCTime += dResult;
//
//
//#endif

        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;

        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);

        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
#if GET_SIGMA_ORIG
    // Get Sigma squared Origs
    m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);

#endif
        
#else
      isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;

        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
//#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
//                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
        
// if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif

#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
//                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
//            
            // Send the isSceneChange --> REmovesd for smooth for now
//            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            

//            // Send the isSceneChange
//            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);

            
//            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
    }// end else Scene change

        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
      
        

#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        

        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
//           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        

#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    

#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
}


// Novemeber 7, 2017
// P frames with sliding window and no look ahead
Void TEncGOP::compressGOPNewInter(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
//Void TEncGOP:: compressGOPNew ( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRec,
//                                     std::list<AccessUnit>& accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE, TComList<TComPicYuv*>& rcListPicYuvOrg )
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
//        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        //        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        //#if SC_FROM_RECONS
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
        //#else
        
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        // This part is from July 11th
        //#if IS_YAO_SCD
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#elif IS_DING_SCD
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time + total SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        //        g_totalSCTime += dResult;
        //
        //#elif IS_SASTRE_SCD
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#else
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        ////        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        //
        //        // Accumlate the total SC Time
        //        g_totalSCTime += dResult;
        //
        //
        //#endif
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        /// Push the original distortion - in compressP Mock
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic)) ;
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
//        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif // end if GET_SIGMA_ORIG
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
//        printf("\n Total SC Time: %12.3f sec.\n", (Double)(clock()-lBefore) / CLOCKS_PER_SEC);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif // end if RUN_IPPP_NOSC
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
            // Calculate current QP offset
            if (pcSlice->getPOC() == end_prop_window+1) {

                m_pcSliceEncoder->calculate4QPOffsets(pcPic, epsilon_array, mu_ij, sigma_squared_in_sliding_window);
            }

            
#if IS_CONSERVATIVE_EPSILON
        m_pcSliceEncoder->modifyQPInterConservative (pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window,
                        end_prop_window, isEpsilonMethodON);
#else
            m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window,
                                             end_prop_window);
#endif
            
            // Move the window
            if (pcSlice->getPOC() == end_prop_window + m_iGopSize) {
                start_prop_window = start_prop_window + m_iGopSize;
                end_prop_window = end_prop_window + m_iGopSize;
                
                cout << "\n^^^^^^^^move the sliding window " << start_prop_window << ", " << end_prop_window << endl;
            }
            
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
        
            
// Hossam: interdep intra modes
// compressGOPInter
// Calculate the intra modes and and not !Is_Sastre --> Not efficient for now
#if IS_CALC_INTERDEP_INTRA_MODES && !IS_SASTRE_SCD
            m_pcSliceEncoder->xExtractSliceInfo(pcPic);
#endif
            
//            printf("\n %d) Total Compress Time: %12.3f sec.\n", pcSlice->getPOC(), (Double)(clock()-lb) / CLOCKS_PER_SEC);
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }

        // Hossam: P frames inter
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
//        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        // Hossam: Inter --
#if IS_DISABLE_TURN_ON_OFF
        isEpsilonMethodON = true;
       if (pcSlice->getPOC() == end_prop_window) {
#else
        if (pcSlice->getPOC() == end_prop_window && isEpsilonMethodON) {
#endif
        
            calculate4Epsilons(pcPic);
        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
//    if(pcSlice->getPOC())
    
}


// March 12, 2018
// P frames with sliding window and no look ahead
Void TEncGOP::compressGOPNewInterConservative(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
//Void TEncGOP:: compressGOPNew ( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRec,
//                                     std::list<AccessUnit>& accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE, TComList<TComPicYuv*>& rcListPicYuvOrg )
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        //        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        //        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        //#if SC_FROM_RECONS
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
        //#else
        
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        // This part is from July 11th
        //#if IS_YAO_SCD
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#elif IS_DING_SCD
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time + total SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        //        g_totalSCTime += dResult;
        //
        //#elif IS_SASTRE_SCD
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#else
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        ////        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        //
        //        // Accumlate the total SC Time
        //        g_totalSCTime += dResult;
        //
        //
        //#endif
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        /// Push the original distortion - in compressP Mock
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic)) ;
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
        //        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif // end if GET_SIGMA_ORIG
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", (Double)(clock()-lBefore) / CLOCKS_PER_SEC);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif // end if RUN_IPPP_NOSC
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
            // Calculate current QP offset
            if (pcSlice->getPOC() == end_prop_window+1) {
                
                m_pcSliceEncoder->calculate4QPOffsets(pcPic, epsilon_array, mu_ij, sigma_squared_in_sliding_window);
            }
            
            
            m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                             m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window);
            
            // Move the window
            if (pcSlice->getPOC() == end_prop_window + m_iGopSize) {
                start_prop_window = start_prop_window + m_iGopSize;
                end_prop_window = end_prop_window + m_iGopSize;
                
                cout << "\n^^^^^^^^move the sliding window " << start_prop_window << ", " << end_prop_window << endl;
            }
            
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            
            
            // Hossam: interdep intra modes
            // Calculate the intra modes and and not !Is_Sastre --> Not efficient for now
#if IS_CALC_INTERDEP_INTRA_MODES && !IS_SASTRE_SCD
            m_pcSliceEncoder->xExtractSliceInfo(pcPic);
#endif
            
            //            printf("\n %d) Total Compress Time: %12.3f sec.\n", pcSlice->getPOC(), (Double)(clock()-lb) / CLOCKS_PER_SEC);
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        // Hossam: P frames inter
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
        //        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        // Hossam: Inter --
#if IS_DISABLE_TURN_ON_OFF
        isEpsilonMethodON = true;
        if (pcSlice->getPOC() == end_prop_window) {
#else
        if (pcSlice->getPOC() == end_prop_window && isEpsilonMethodON) {
#endif
            
            calculate4Epsilons(pcPic);
        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
    //    if(pcSlice->getPOC())
    
}


// Novemeber 21, 2017
// P frames with sliding window and no look ahead
// Hossam: SCs static will not help you
Void TEncGOP::compressGOPNewInterSC(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
//Void TEncGOP:: compressGOPNew ( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRec,
//                                     std::list<AccessUnit>& accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE, TComList<TComPicYuv*>& rcListPicYuvOrg )
{
    
        cout << "Yang: TEncGOP: compressGOPNewInterSC: NEW Yalla beena :)" << "\n" << endl;
//        getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        //        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD || IS_SCENE_CHANGE_POC
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================

// for all bench marks get the original sigma squared first to avoid exceptions below
#if IS_YAO_SCD || IS_DING_SCD || IS_SASTRE_SCD || IS_SCENE_CHANGE_POC
        
        // Hossam: Add this method in order to make sure that you operate at the same QP for getting sigma squared ORG
        // Modify what you did after you get the sigma squared to be consistent in all cases
        m_pcSliceEncoder->setMockQPForSCOperation( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window );
        
        // Get the original sigma squared
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(),pcSlice, rcListPic, pcPic));

//        cout << " Output 11111 : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
        
                UInt _lastSC_bench = m_pcEncTop->getSceneChangeCoder()->getLastSC();
                UInt relativePOC_bench = _lastSC_bench==-1? pcSlice->getPOC(): pcSlice->getPOC()-_lastSC_bench;
        
                //         cout << "Check isScene Change to reset window parameters " << ", isSceneChange: " << isSceneChange << " , lastSc " << m_pcEncTop->getSceneChangeCoder()->getLastSC() << " , window: " << start_prop_window << ", " << end_prop_window << ", scState: "  <<  m_pcEncTop->getSceneChangeCoder()->getSCState() << endl;
                //        cout << " Relative POC " << relativePOC << endl;
        
        
                // Calculate current QP offset -- push the epsilons inside slice encoder
                if (relativePOC_bench == end_prop_window+1) {
        
                    m_pcSliceEncoder->calculate4QPOffsets(pcPic, epsilon_array, mu_ij, sigma_squared_in_sliding_window);
                }
        
        
                m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                                 m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window);

        // Move the window
        if (relativePOC_bench == end_prop_window + m_iGopSize) {
            start_prop_window = start_prop_window + m_iGopSize;
            end_prop_window = end_prop_window + m_iGopSize;
            
            cout << "\n^^^^^^^^move the sliding window " << start_prop_window << ", " << end_prop_window << endl;
        }
        
#endif
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#elif IS_SCENE_CHANGE_POC
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
#elif IS_DING_SCD
        
        // starting SC time
//        Double dResult;
//        clock_t lBefore = clock();
   
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//        if (pcSlice->getPOC() == 0 ) {
//            dResult = 0;
//        }
//        else
//            // ending SC time + total SC time
//            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
//        
//        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
//        Double dResult;
//        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        // Hossam: Add this method in order to make sure that you operate at the same QP for getting sigma squared ORG
        // Modify what you did after you get the sigma squared to be consistent in all cases
//        m_pcSliceEncoder->setMockQPForSCOperation( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window );

        // Check isSceneChange and also calculate sigma squared with you
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeInter(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        /// Push the original distortion - in compressP Mock (I think that you can use the current sigma flag here)
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal()) ;
        
//        cout << " Output 22222 : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;

        
        // isSceneChange
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
//        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
//        if (pcSlice->getPOC() == 0 ) {
//            dResult = 0;
//        }
//        else
//            // ending SC time + total SC time
//            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
//        
//        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
//        
//        // Accumlate the total SC Time
//        g_totalSCTime += dResult;
        
        
#endif // end #if IS_YAO_SCD
        
        // Calculate the SC time outside the if statement to enable the calculations for all algorithms
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        
//         cout << "(Before) Check isScene Change to reset window parameters " << ", isSceneChange: " << isSceneChange << " , lastSc " << m_pcEncTop->getSceneChangeCoder()->getLastSC() << " , window: " << start_prop_window << ", " << end_prop_window << ", scState: "  <<  m_pcEncTop->getSceneChangeCoder()->getSCState() << endl;
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD || IS_SCENE_CHANGE_POC
            // reset the window parameters for QP
            if(m_pcEncTop->getSceneChangeCoder()->getSCState() == 0) {
                resetWindowParamtersEps();
                m_pcSliceEncoder->reset4Epsilons();
            }
#endif
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
//        cout << "(Between) Check isScene Change to reset window parameters " << ", isSceneChange: " << isSceneChange << " , lastSc " << m_pcEncTop->getSceneChangeCoder()->getLastSC() << " , window: " << start_prop_window << ", " << end_prop_window << ", scState: "  <<  m_pcEncTop->getSceneChangeCoder()->getSCState() << endl;
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
//            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
//            // Calculate current QP offset
//            if (pcSlice->getPOC() == end_prop_window+1) {
//                
//                m_pcSliceEncoder->calculate4QPOffsets(pcPic, epsilon_array, mu_ij, sigma_squared_in_sliding_window);
//            }
//            
//            
//            m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                             m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window);
//            
//            // Move the window
//            if (pcSlice->getPOC() == end_prop_window + m_iGopSize) {
//                start_prop_window = start_prop_window + m_iGopSize;
//                end_prop_window = end_prop_window + m_iGopSize;
//                
//                cout << "\n^^^^^^^^move the sliding window " << start_prop_window << ", " << end_prop_window << endl;
//            }
            
        }// end else Scene change
        
//         cout << "Check isScene Change to reset window parameters " << ", isSceneChange: " << isSceneChange << " , lastSc " << m_pcEncTop->getSceneChangeCoder()->getLastSC() << " , window: " << start_prop_window << ", " << end_prop_window << ", scState: "  <<  m_pcEncTop->getSceneChangeCoder()->getSCState() << endl;
//        cout << " Relative POC " << relativePOC << endl;
        
// hossam: need to check XX (i updated it to only do the QP updates in my SCDs)
#if IS_STUDENT_SCD || IS_STUDENT_Energy_SCD
        
        // reset the window parameters for QP
        if(isSceneChange && m_pcEncTop->getSceneChangeCoder()->getSCState() == 0) {
            
//            cout << " RESET ACTION ON SCCCCC " << endl;
            resetWindowParamtersEps();
            m_pcSliceEncoder->reset4Epsilons();
        }
        
        // MODIFY QP
        UInt _lastSC = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        UInt relativePOC = _lastSC==-1? pcSlice->getPOC(): pcSlice->getPOC()-_lastSC;

        // Calculate current QP offset -- push the epsilons inside slice encoder
        if (relativePOC == end_prop_window+1) {
            
            m_pcSliceEncoder->calculate4QPOffsets(pcPic, epsilon_array, mu_ij, sigma_squared_in_sliding_window);
        }
        
        
        m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                         m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window);
        
        
        // Move the window
        if (relativePOC == end_prop_window + m_iGopSize) {
            start_prop_window = start_prop_window + m_iGopSize;
            end_prop_window = end_prop_window + m_iGopSize;
            
            cout << "\n^^^^^^^^move the sliding window " << start_prop_window << ", " << end_prop_window << endl;
        }

#else
        
        // Hossam: If it is a SC
        // at least in YAO AND OTHER METHODS THAT needs a double pass
        // You need to redefine the QP here to operate and encode again correctly
        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            m_pcSliceEncoder->modifyQPInter ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                             m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window);
        }
        
#endif
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
// Passant Mahmoud -- Only if it's a scene change reencode skip encoding
#if IS_YAO_SCD || IS_SASTRE_SCD // Skip encoding is within in the cases of YOA and Sastre
        if (isSceneChange || pcSlice->getPOC() == 0) {
#endif
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
// Hossam: interdep intra modes
// Calculate the intra modes and and not !Is_Sastre --> Not efficient for now
#if IS_CALC_INTERDEP_INTRA_MODES && !IS_SASTRE_SCD
            m_pcSliceEncoder->xExtractSliceInfo(pcPic);
#endif
            
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        } // end while loop

// Passant Mahmoud
#if IS_YAO_SCD || IS_SASTRE_SCD
        }// end skip encoding for YAO and Sastre
#endif
        
        // Moved it from up there to here
        // Hossam: Reset the Scene change flag
        isSceneChange = false;

 // Update the intra count of the previous frame for sastre method
#if IS_SASTRE_SCD
        m_pcSliceEncoder->xExtractSliceInfo(pcPic);
        // Update the weighted average! Now, the last encoded frame is (k+1)
        m_pcSliceEncoder-> sastre_intra_count_tillK = pcSlice->intra_modes;
#endif
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        // Hossam: P frames inter
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
        //        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        // Hossam: Inter --
        UInt _lastSC1 = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        UInt relativePOC1 = _lastSC1==-1? pcSlice->getPOC(): pcSlice->getPOC()-_lastSC1;
        
//        cout << "\nAbout to calculate 4 Epsilons " << relativePOC1 << ", = end_prop_window " << end_prop_window << endl;
//        if (pcSlice->getPOC() == end_prop_window) {
        if (relativePOC1 == end_prop_window) {
        
            calculate4Epsilons(pcPic);
        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
    
    //    if(pcSlice->getPOC())
    
}


// July 19, 2018
Void TEncGOP::compressGOPNewInterMuMult(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        //        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        //        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        //#if SC_FROM_RECONS
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
        //#else
        
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        // This part is from July 11th
        //#if IS_YAO_SCD
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#elif IS_DING_SCD
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time + total SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        //        g_totalSCTime += dResult;
        //
        //#elif IS_SASTRE_SCD
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#else
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        ////        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        //
        //        // Accumlate the total SC Time
        //        g_totalSCTime += dResult;
        //
        //
        //#endif
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        /// Push the original distortion
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic)) ;
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
        //        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
            // Calculate current QP offset
            Double curr_epislon_i = (pcSlice->getPOC() == end_prop_window_mu + 1)? epsilon_array.front(): 12.0;
            m_pcSliceEncoder->calculateCurrentQPOffset( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu, curr_epislon_i);
            
            m_pcSliceEncoder->modifyQPInterMu ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu);
            
            
            start_prop_window_mu = (pcSlice->getPOC() == end_prop_window_mu + 1)? ( 1 + start_prop_window_mu):start_prop_window_mu;
            end_prop_window_mu = (pcSlice->getPOC() == end_prop_window_mu + 1)? ( 1 + end_prop_window_mu):end_prop_window_mu;
            
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // compressGOPNewInterMu
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            
            // Hossam: interdep intra modes
            // Calculate the intra modes and and not !Is_Sastre --> Not efficient for now
            // compressGOPNewInterMu
#if IS_CALC_INTERDEP_INTRA_MODES && !IS_SASTRE_SCD
            m_pcSliceEncoder->xExtractSliceInfo(pcPic);
#endif
            
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    // compressGOPNewInterMu
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if IS_RATE_DISTORSION_EXPERIMENT
                    if(pcPic->getPOC() == 21)
                    {
                        // With respect to P
                        static int off_ref [] = {-5, -2, -3, -4};
                        Int test_pred_poc = 17;
                        Int fetch_index = test_pred_poc % 4 == 0? 3: test_pred_poc % 4 - 1;
                        Int test_ref1_poc = test_pred_poc - 1; Int test_ref2_poc = test_pred_poc + off_ref[fetch_index];
                        
                        // rates
                        Int RPredref1  = m_pcSliceEncoder->reference1_bits_perFrame.at(test_pred_poc);
                        Int RPredref2  = m_pcSliceEncoder->reference2_bits_perFrame.at(test_pred_poc);
                        
                        // Dump RPredref1
                        string fileName = "";
                        std::ostringstream oss;
                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-" << g_qpInit  << ".txt";
                        fileName = oss.str();
                        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        FILE* mse_pFile = fopen (pYUVFileName, "at");
                        //                   fprintf(mse_pFile, "%6.4lf \t %10d \n", MSEyuvframe[COMPONENT_Y], uibits);
                        fprintf(mse_pFile, "%d \n", RPredref1);
                        fclose(mse_pFile);
                        
                        
                        //                        // Dump RPredref1/Total Rate
                        //                        oss.str(""); oss.clear();
                        //                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-Perc-" << g_qpInit << ".txt";
                        //                        fileName = oss.str();
                        //                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        //                        mse_pFile = fopen (pYUVFileName, "at");
                        //                        fprintf(mse_pFile, "%f \n", 100.0*(RPredref1/rate_in_sliding_window.at(test_pred_poc)));
                        //                        fclose(mse_pFile);
                        
                        // Dump RPredref2
                        oss.str(""); oss.clear();
                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-" << g_qpInit << ".txt";
                        fileName = oss.str();
                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        mse_pFile = fopen (pYUVFileName, "at");
                        fprintf(mse_pFile, "%d \n", RPredref2);
                        fclose(mse_pFile);
                        
                        //                        hashtaka
                        // Dump RPredref2/Total Rate
                        //                        oss.str(""); oss.clear();
                        //                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-Perc-" << g_qpInit << ".txt";
                        //                        fileName = oss.str();
                        //                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        //                        mse_pFile = fopen (pYUVFileName, "at");
                        //                        fprintf(mse_pFile, "%f \n", 100.0*(RPredref2/rate_in_sliding_window.at(test_pred_poc)));
                        //                        fclose(mse_pFile);
                        
                        
                    }
#endif
                    
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        // Hossam: P frames inter
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
        //        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
#if IS_RATE_DISTORSION_EXPERIMENT
        // hashtaka
        //        cout << "\n**********Hashtaka !!! " << pcPic->getPOC() << endl;
        if(pcPic->getPOC() == 21)
        {
            // With respect to P
            static int off_ref [] = {-5, -2, -3, -4};
            Int test_pred_poc = 17;
            Int fetch_index = test_pred_poc % 4 == 0? 3: test_pred_poc % 4 - 1;
            Int test_ref1_poc = test_pred_poc - 1; Int test_ref2_poc = test_pred_poc + off_ref[fetch_index];
            
            // rates
            Int RPredref1  = m_pcSliceEncoder->reference1_bits_perFrame.at(test_pred_poc);
            Int RPredref2  = m_pcSliceEncoder->reference2_bits_perFrame.at(test_pred_poc);
            
            string fileName = "";
            std::ostringstream oss;
            
            // Dump RPredref1/Total Rate
            oss.str(""); oss.clear();
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-Perc-" << g_qpInit << ".txt";
            fileName = oss.str();
            Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
            FILE* mse_pFile = fopen (pYUVFileName, "at");
            
            //            cout << "\nTotal Bits: " << rate_in_sliding_window.back() << ", Ref1: " << RPredref1 << endl;
            fprintf(mse_pFile, "%f \n", 100.0*RPredref1/rate_in_sliding_window.at(test_pred_poc));
            fclose(mse_pFile);
            
            // Dump RPredref2/Total Rate
            oss.str(""); oss.clear();
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-Perc-" << g_qpInit << ".txt";
            fileName = oss.str();
            pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
            mse_pFile = fopen (pYUVFileName, "at");
            fprintf(mse_pFile, "%f \n", 100.0*RPredref2/rate_in_sliding_window.at(test_pred_poc));
            fclose(mse_pFile);
            
            
        }
#endif
        
        
        
        // Hossam: Inter -- SC + MU
        //        if (pcSlice->getPOC() == end_prop_window_mu) {
//                cout << "\n\n\n====isMumethod in GOP " << isMuMethodON << ", poc " << pcSlice->getPOC() << ", endW: " << end_prop_window_mu << endl;
        if (pcSlice->getPOC() == end_prop_window_mu && isMuMethodON) {
            //          if (pcSlice->getPOC() == end_prop_window_mu) {
            calculateCurrentEpsilonMu(pcPic);

        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
        
} // end compressGOPNewInterMuMult
    
// Novemeber 7, 2017
// P frames with sliding window and no look ahead -- mu prediction method
Void TEncGOP::compressGOPNewInterMu(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
//Void TEncGOP:: compressGOPNew ( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRec,
//                                     std::list<AccessUnit>& accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE, TComList<TComPicYuv*>& rcListPicYuvOrg )
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        //        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
        //        Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //         Bool isSceneChange = pcSlice->getPOC() == 11;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = pcSlice->getPOC() == 11 || pcSlice->getPOC() == 17 || pcSlice->getPOC() == 25;// || pcSlice->getPOC() == 11;
        
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        //#if SC_FROM_RECONS
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangePOC(pcSlice->getPOC());
        //#else
        
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        // This part is from July 11th
        //#if IS_YAO_SCD
        //            isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#elif IS_DING_SCD
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time + total SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        //        g_totalSCTime += dResult;
        //
        //#elif IS_SASTRE_SCD
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //#else
        //
        //        // starting SC time
        //        Double dResult;
        //        clock_t lBefore = clock();
        //        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        //
        //        // ending SC time
        //        dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        ////        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        //
        //        // Accumlate the total SC Time
        //        g_totalSCTime += dResult;
        //
        //
        //#endif
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
       
// compressGOPInterNewMU
#if IS_INTER_DEP_MULTIPLE_REF
        
        /// Push the original distortion based on ref 0
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic, 0)) ;

        /// Push the original distortion based on ref 1
        sigma_squared_in_sliding_window_Ref1.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic, 1)) ;
        
        // Used for debugging: Print out the sigma and distortion contents
//        displayDAndSigmaSlidingWindowList(pcSlice->getPOC());
#else
        /// Push the original distortion
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic)) ;
#endif
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
        //        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
            // Calculate current QP offset
            Double curr_epislon_i = (pcSlice->getPOC() == end_prop_window_mu + 1)? epsilon_array.front(): 12.0;
            m_pcSliceEncoder->calculateCurrentQPOffset( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu, curr_epislon_i);
            
            m_pcSliceEncoder->modifyQPInterMu ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                             m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu);
            

            start_prop_window_mu = (pcSlice->getPOC() == end_prop_window_mu + 1)? ( 1 + start_prop_window_mu):start_prop_window_mu;
            end_prop_window_mu = (pcSlice->getPOC() == end_prop_window_mu + 1)? ( 1 + end_prop_window_mu):end_prop_window_mu;
            
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // compressGOPNewInterMu
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            
// Hossam: interdep intra modes
// Calculate the intra modes and and not !Is_Sastre --> Not efficient for now
// compressGOPNewInterMu
#if IS_CALC_INTERDEP_INTRA_MODES && !IS_SASTRE_SCD
            m_pcSliceEncoder->xExtractSliceInfo(pcPic);
#endif
            
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    // compressGOPNewInterMu
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if IS_RATE_DISTORSION_EXPERIMENT
                    if(pcPic->getPOC() == 21)
                    {
                        // With respect to P
                        static int off_ref [] = {-5, -2, -3, -4};
                        Int test_pred_poc = 17;
                        Int fetch_index = test_pred_poc % 4 == 0? 3: test_pred_poc % 4 - 1;
                        Int test_ref1_poc = test_pred_poc - 1; Int test_ref2_poc = test_pred_poc + off_ref[fetch_index];
                    
                        // rates
                        Int RPredref1  = m_pcSliceEncoder->reference1_bits_perFrame.at(test_pred_poc);
                        Int RPredref2  = m_pcSliceEncoder->reference2_bits_perFrame.at(test_pred_poc);
                        
                        // Dump RPredref1
                        string fileName = "";
                        std::ostringstream oss;
                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-" << g_qpInit  << ".txt";
                        fileName = oss.str();
                        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        FILE* mse_pFile = fopen (pYUVFileName, "at");
                        //                   fprintf(mse_pFile, "%6.4lf \t %10d \n", MSEyuvframe[COMPONENT_Y], uibits);
                        fprintf(mse_pFile, "%d \n", RPredref1);
                        fclose(mse_pFile);
                        
                        
//                        // Dump RPredref1/Total Rate
//                        oss.str(""); oss.clear();
//                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-Perc-" << g_qpInit << ".txt";
//                        fileName = oss.str();
//                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//                        mse_pFile = fopen (pYUVFileName, "at");
//                        fprintf(mse_pFile, "%f \n", 100.0*(RPredref1/rate_in_sliding_window.at(test_pred_poc)));
//                        fclose(mse_pFile);
                        
                        // Dump RPredref2
                        oss.str(""); oss.clear();
                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-" << g_qpInit << ".txt";
                        fileName = oss.str();
                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
                        mse_pFile = fopen (pYUVFileName, "at");
                        fprintf(mse_pFile, "%d \n", RPredref2);
                        fclose(mse_pFile);
                        
//                        hashtaka
                        // Dump RPredref2/Total Rate
//                        oss.str(""); oss.clear();
//                        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-Perc-" << g_qpInit << ".txt";
//                        fileName = oss.str();
//                        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//                        mse_pFile = fopen (pYUVFileName, "at");
//                        fprintf(mse_pFile, "%f \n", 100.0*(RPredref2/rate_in_sliding_window.at(test_pred_poc)));
//                        fclose(mse_pFile);

                        
                    }
#endif
                    
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        // Hossam: P frames inter
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
        //        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );

#if IS_RATE_DISTORSION_EXPERIMENT
        // hashtaka
//        cout << "\n**********Hashtaka !!! " << pcPic->getPOC() << endl;
        if(pcPic->getPOC() == 21)
        {
            // With respect to P
            static int off_ref [] = {-5, -2, -3, -4};
            Int test_pred_poc = 17;
            Int fetch_index = test_pred_poc % 4 == 0? 3: test_pred_poc % 4 - 1;
            Int test_ref1_poc = test_pred_poc - 1; Int test_ref2_poc = test_pred_poc + off_ref[fetch_index];
            
            // rates
            Int RPredref1  = m_pcSliceEncoder->reference1_bits_perFrame.at(test_pred_poc);
            Int RPredref2  = m_pcSliceEncoder->reference2_bits_perFrame.at(test_pred_poc);
            
            string fileName = "";
            std::ostringstream oss;
            
            // Dump RPredref1/Total Rate
            oss.str(""); oss.clear();
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1Bits-Perc-" << g_qpInit << ".txt";
            fileName = oss.str();
            Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
            FILE* mse_pFile = fopen (pYUVFileName, "at");
            
//            cout << "\nTotal Bits: " << rate_in_sliding_window.back() << ", Ref1: " << RPredref1 << endl;
            fprintf(mse_pFile, "%f \n", 100.0*RPredref1/rate_in_sliding_window.at(test_pred_poc));
            fclose(mse_pFile);
            
            // Dump RPredref2/Total Rate
            oss.str(""); oss.clear();
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2Bits-Perc-" << g_qpInit << ".txt";
            fileName = oss.str();
            pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
            mse_pFile = fopen (pYUVFileName, "at");
            fprintf(mse_pFile, "%f \n", 100.0*RPredref2/rate_in_sliding_window.at(test_pred_poc));
            fclose(mse_pFile);
            
            
        }
#endif
        
       
        
        // Hossam: Inter -- Normal mu
//        if (pcSlice->getPOC() == end_prop_window_mu) {
//       cout << "\n\n\n====isMumethod Normal Mu in GOP " << isMuMethodON << ", poc " << pcSlice->getPOC() << ", endW: " << end_prop_window_mu << endl;
        if (pcSlice->getPOC() == end_prop_window_mu && isMuMethodON) {
//          if (pcSlice->getPOC() == end_prop_window_mu) {
        
#if IS_INTER_DEP_MULTIPLE_REF
            calculateCurrentEpsilonMuMult(pcPic);
#else
            calculateCurrentEpsilonMu(pcPic);
#endif

        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
    
    //    if(pcSlice->getPOC())
    
}


// Novemeber 21, 2017
// P frames with sliding window and no look ahead -- mu prediction method -- scene change
Void TEncGOP::compressGOPNewInterMuSC(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //        cout << "Yang: TEncGOP: compressGOP: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    // 4
    //    cout << "iPOCLast " << iPOCLast << endl;
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        //        cout << " POC Curr Org " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", gPOC " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
    
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        // Hossam: Setting the slice type -- Code Tweaking!!
        //=================================================================
        
        /*
         Int sc = pcSlice->getPOC();
         if(sc == 2)
         {
         cout << "\nYang: TEncGOP: compressGOP: Forcing an I frame " << sc << "\n" << endl;
         //    getchar();
         pcSlice->setSliceType(I_SLICE);
         //        getchar();
         }
         else
         */
        // Hossam: Setting the slice type -- Code Tweaking ENDS!!
        //=================================================================
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        //        cout << "Slice Type: " << pcSlice->getSliceType() << endl;
        //        cout << "Slice Directions: " << (pcSlice->isInterP()? 1:2) << endl;
        //
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
    
// for all bench marks get the original sigma squared first to avoid exceptions below
#if IS_YAO_SCD || IS_DING_SCD || IS_SASTRE_SCD
        
        // Add this method in order to make sure that you operate at the same QP for scene change
        // Modify what you have done after you get the sigma squared to be consistent in all cases
        m_pcSliceEncoder->setMockQPForSCOperation( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu );
        
        // Get the original sigma squared
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(),pcSlice, rcListPic, pcPic));
        
        // MODIFY QP
        UInt __lastSC = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        UInt _relativePOC = __lastSC==-1? pcSlice->getPOC(): pcSlice->getPOC()-__lastSC;
        
        Double curr_epislon_i = (_relativePOC == end_prop_window_mu + 1)? epsilon_array.front(): 12.0;
        m_pcSliceEncoder->calculateCurrentQPOffset( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,  isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu, curr_epislon_i);
        
        m_pcSliceEncoder->modifyQPInterMu ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                           m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu);
        
        //        cout << " Output : " << m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal() << endl;
#endif
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        // You need to init all other SCDs with normal Qps
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        

        // Hossam: Not needed - already done in the initAttempt
//         m_pcSliceEncoder->setMockQPForSCOperation( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window, end_prop_window );
        
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        // Check isSceneChange and also calculate sigma squared with you
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeInter(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        /// Push the original distortion - in compressP Mock
        sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOriginal()) ;
        
#endif
        
        
        // Sc time for all
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //        // HARD CODE
        //        if (pocCurr == 59) {
        //            isSmooth = true;
        //        }
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            

#if IS_DING_SCD || IS_SASTRE_SCD || IS_YAO_SCD
            // reset the window parameters for QP
            if(m_pcEncTop->getSceneChangeCoder()->getSCState() == 0) {
                resetWindowParamtersMu();
                m_pcSliceEncoder->reset4Epsilons();
            }
#endif
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag -- will not work for the rest of the benchmarks
//            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            
            
        }// end else Scene change
        
        // Declare the variables here to use them in moving counters after #ifdef
        UInt _lastSC = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        UInt relativePOC = _lastSC==-1? pcSlice->getPOC(): pcSlice->getPOC()-_lastSC;
        
#if IS_STUDENT_SCD || IS_STUDENT_Energy_SCD
        // reset the window parameters for QP
        if(isSceneChange && m_pcEncTop->getSceneChangeCoder()->getSCState() == 0) {
            resetWindowParamtersMu();
            m_pcSliceEncoder->reset4Epsilons();
        }
        
        // Calculate current QP offset
        // MODIFY QP
        
        Double curr_epislon_i = (relativePOC == end_prop_window_mu + 1)? epsilon_array.front(): 12.0;
        m_pcSliceEncoder->calculateCurrentQPOffset( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,  isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu, curr_epislon_i);
        
        m_pcSliceEncoder->modifyQPInterMu ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                           m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu);
        
#else
        
        // Hossam: If it is a SC
        // at least in YAO AND OTHER METHODS THAT needs a double pass
        // You need to redefine the QP here to operate and encode again correctly
        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Double curr_epislon_i = (relativePOC == end_prop_window_mu + 1)? epsilon_array.front(): 12.0;
            m_pcSliceEncoder->calculateCurrentQPOffset( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,  isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu, curr_epislon_i);
            
            m_pcSliceEncoder->modifyQPInterMu ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth, start_prop_window_mu, end_prop_window_mu);
        }
        
        
#endif
        
        // Move the counters
        start_prop_window_mu = (relativePOC == end_prop_window_mu + 1)? ( 1 + start_prop_window_mu):start_prop_window_mu;
        end_prop_window_mu = (relativePOC == end_prop_window_mu + 1)? ( 1 + end_prop_window_mu):end_prop_window_mu;

        
        
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        // Passant Mahmoud -- Only if it's a scene change reencode skip encoding
#if IS_YAO_SCD || IS_SASTRE_SCD // Skip encoding is within in the cases of YOA and Sastre
        if (isSceneChange || pcSlice->getPOC() == 0) {
//        if (true) {
#endif
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        } // end while loop
            
// Passant Mahmoud
#if IS_YAO_SCD || IS_SASTRE_SCD
        }// end skip encoding for YAO and Sastre
#endif
        // Moved it from up there to here
        // Hossam: Reset the Scene change flag
        isSceneChange = false;
        
// Update the intra count of the previous frame for sastre method
#if IS_SASTRE_SCD
        m_pcSliceEncoder->xExtractSliceInfo(pcPic);
        // Update the weighted average! Now, the last encoded frame is (k+1)
        m_pcSliceEncoder-> sastre_intra_count_tillK = pcSlice->intra_modes;
#endif
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        // Hossam: P frames inter (muSc)
        xCalculateAddPSNRInter(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
        //        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        
        
        // Hossam: Inter --
        UInt _lastSC1 = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        UInt relativePOC1 = _lastSC1==-1? pcSlice->getPOC(): pcSlice->getPOC()-_lastSC1;
//        if (relativePOC1 == end_prop_window_mu) {
//            calculateCurrentEpsilonMu(pcPic);
//        }
        if (relativePOC1 == end_prop_window_mu && isMuMethodON) {
            calculateCurrentEpsilonMu(pcPic);
        }
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
    
    //    if(pcSlice->getPOC())
    
}


// October 30, 2017
/////// P Frames Look Ahead
Void TEncGOP::compressGOPNewPMock(Bool isMockEncoding, Bool isAddPSNR, TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //    cout << "Yang: TEncGOP: compressGOP Pee: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method (Init GOP size)
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
//    cout << "Start compressGOPNewPMOck Mock show me rcList " << endl;
//    showMeRcListsGOP(rcListPic);
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
  
    // shams el mock
//    cout << "Pictures coded so far mock " << m_iNumPicCoded << endl;
//    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids Until GOP size
    //    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    // shams el mock
//    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
//    {
    
    Int iGOPid = general_GOP_id;
    
    // If POCLast is 1 or more, incremenet GopID (0, 0, 1, 2, 3, 0, 1, 2, 3)
    if(iPOCLast > 0)
    {
        incrGOPId();
    }
        
//        cout << "Yang: TEncGOP: compressGOPNewPMock: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
//            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            
            // Hossam: look ahead
//            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC + 1;

            
            if(iPOCLast !=0)
            {
                if(iPOCLast % m_iGopSize == 0)
                {
                    pocCurrFactor = (iPOCLast-1)/m_iGopSize;
                }
                else{
                    pocCurrFactor = iPOCLast/m_iGopSize;
                }
            }
            
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0) +
            pocCurrFactor*m_iGopSize;
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
    
//        if(iPOCLast !=0 && iPOCLast % m_iGopSize == 0)
//        {
//            cout << "Increment POC Curr Factor " << endl;
//            pocCurrFactor++;
//        }
    
//            cout << " POC Curr Mock " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", poc from G: " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;

//        cout << " POC Current22222 not 04 Mock" << pocCurr << ", iPOCLast: " << iPOCLast << endl;
    
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            // shams el mock
            return;
//            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP

        xGetBufferMock( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
//        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
    
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
    
    
        /// Push the original distortion - in compressP Mock
        if(sigma_squared_in_sliding_window.size() > progress_in_sliding_window)
        {
            sigma_squared_in_sliding_window[progress_in_sliding_window] = m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        }
        else{
            sigma_squared_in_sliding_window.push_back(m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic)) ;

        }
        cout << "Need to remove the getSigmaSquared ORG from the actualCompressGOP -- WASTE of time!! " << sigma_squared_in_sliding_window[progress_in_sliding_window] << endl;
        ///
    
    
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
//#if GET_SIGMA_ORIG
//        // Get Sigma squared Origs
//        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
//        
//#endif
    
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop ->lo getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
//            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            m_pcSliceEncoder->modifyQPMock ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);

        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        } // end while (nextCuAddr < end)
        
        //        maybe a flag here! Awel haga this flag is just to do compression
        //        if(isMockEncoding) {
        //            cout << "compressGOP: isMockEncoding stop compressGOP in the middle " << pcSlice->getPOC() << endl;
        //            return;
        //        }
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirstLookAhead )
        {
//                        cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirstLookAhead)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirstLookAhead = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
                
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
                
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
                
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        
//                        cout << "(nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx]) " << nextCUAddr << endl;
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
//                    cout << "1) actualHeadBits for Slice header " << actualHeadBits << ", tot " << actualTotalBits << endl;
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
//                    cout << "2) actualHeadBits for Slice header " << actualHeadBits << ", tot " << actualTotalBits << endl;
//                    cout << "0) pcSubstreamsOut[0].getNumberOfWrittenBits(): " << pcSubstreamsOut[0].getNumberOfWrittenBits() << endl;
                    
                    if(pcSlice->isNextSlice())
                    {
//                        cout << "if(pcSlice->isNextSlice())" << endl;
                        
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
//                    cout << "1) pcSubstreamsOut[0].getNumberOfWrittenBits(): " << pcSubstreamsOut[0].getNumberOfWrittenBits() << endl;
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
//                    cout << "22) pcSubstreamsOut[0].getNumberOfWrittenBits(): " << pcSubstreamsOut[0].getNumberOfWrittenBits() << endl;
                    
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        
//                        cout << "pcSlice->getSubStreamSizes() " << pcSlice->getSubstreamSizes()[0] << endl;
//                        cout << "iNumSubstreams: " << iNumSubstreams  << ", totalCodeSizeBefore " << uiTotalCodedSize << endl << endl;
//                        cout << "2) pcSubstreamsOut[0].getNumberOfWrittenBits(): " << pcSubstreamsOut[0].getNumberOfWrittenBits() << endl;
                        
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
//                            cout << "uiTotalCodedSize " << uiTotalCodedSize << endl;
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    
//                    cout << "actualTotalBits before " << actualTotalBits << endl;
                    
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    
//                    cout << "actualTotalBits after " << actualTotalBits << endl;
                    
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                        
//                        cout << "accessUnit.push_back(new NALUnitEBSP(nalu));" << endl;
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                } // end encode Slice
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // Hossam:
                    
//                    if(pcPic->getPOC() == 4) {
//                        cout << "\n &&&&&&&&MockBeforeSAOProcess Before&&&&&&&&&& \n" << endl;
//                        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//                        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//                    }
                    
                    
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        
                        
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                            
//                            cout << pcPic->getPOC() << ") SET SAO ENABLED FLAG " << pcPic -> getSlice(s)->getSaoEnabledFlag(toChannelType(COMPONENT_Y)) << pcPic -> getSlice(s)->getSaoEnabledFlag(toChannelType(COMPONENT_Cr)) << pcPic -> getSlice(s)->getSaoEnabledFlag(toChannelType(COMPONENT_Cb)) << endl;
                        }
                    }
                    
//                    if(pcPic->getPOC() == 4) {
//                        cout << "\n &&&&&&&&MockAfterSAOProcess After&&&&&&&&&& \n" << endl;
//                        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//                        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
            
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        
        // Hossam: LookAhead P frames
        //        if(isAddPSNR) {

        xCalculateAddPSNRMock(pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE);
//        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        // Hossam: if not mock encoding add the MD5
        if(!isMockEncoding) {
        
            if (!digestStr.empty())
            {
                if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
                {
                    printf(" [MD5:%s]", digestStr.c_str());
                }
                else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
                {
                    printf(" [CRC:%s]", digestStr.c_str());
                }
                else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
                {
                    printf(" [Checksum:%s]", digestStr.c_str());
                }
            }
            
        }// end Hossam: MockEncoding
    
    
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
    
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();

//    cout << "Null current recons " << (pcPic->getPicYuvRec()) << " or the out " << (pcPicYuvRecOut) << endl;
    
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
    // Hossam: LookAhead You do not need to copy the output to reconstructed pictures out
//        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
    
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
//    } // end for loop Gop ids shams el mock
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
    
//    cout << "Mismatch in number of pictures coded and number of pictures rvd " << m_iNumPicCoded << ", " << iNumPicRcvd << endl;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
    
    // Case first frame
    if(iPOCLast == 0)
    {
//        cout << "Case first frame decrement coded pics in EncGOP " << endl;
        m_iNumPicCoded--;
    }
    
} // end compressGOPNewPMock




// October 30, 2017
/////// P Frames Look Ahead
Void TEncGOP::compressGOPNewP(Bool isMockEncoding, Bool isAddPSNR, TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
//    cout << "Yang: TEncGOP: compressGOP Pee ACTUAL : NEW Yalla beena :)" << "\n" << endl;
//    cout << "Yang: TEncGOP: compressGOP Pee: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method (Init GOP size)
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
//    m_iNumPicCoded = 0;
//    m_iNumPicCodedActual = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }

            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids Until GOP size
//    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    
//    shams el 3'roob
//    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
//    {
//    Int iGOPid = general_GOP_id;
    
    Int iGOPid = actual_GOP_id;
    
    // If POCLast is 1 or more, incremenet GopID (0, 0, 1, 2, 3, 0, 1, 2, 3)
    if(iPOCLast > 0)
    {
        incrGOPIdActual();
    }
    
//                  cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
//            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0) + pocCurrFactorActual*m_iGopSize;
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
    
    
//        cout << " POC Curr Actual " << pocCurr << ", iPOCLast: " << iPOCLast << ", iNumPicRcvd: " << iNumPicRcvd << ", iGOPid: " << iGOPid << ", poc from G: " <<  m_pcCfg->getGOPEntry(iGOPid).m_POC << endl;
    
    
    
    
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
        
//            // shams el 3'roob
            return;
//            continue;
        }
    
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
//        int b = rcListPic.size();
//        for(int g = 0; g < b ; g++)
//        {
//            cout << "Pop " << g << endl;
//            rcListPic.popBack();
//        }
//        cout << "sz: rcList "  << rcListPic.size() << endl;
        
//        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        xGetBufferActual( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );

    
        if(iPOCLast !=0 && iPOCLast % m_iGopSize == 0)
        {
//            cout << "Actual Increment POC Curr Factor " << endl;
            pocCurrFactorActual++;
        }
    
//    cout << "Replace xGetBuffer with xGetBufferActual to remove the future pictures from the list " << endl;
//    xGetBufferActual( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );

    
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
      
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
    
    
//    cout << "To avoid poc=1 lost error, I added a modifyRCList like the scene change after the select, there is something that marks the reference to false " << endl;
        pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
    
    //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
    
    
        // Once I reach the p, you can go ahead and calculate the epsilon
        // no need to issue a command from outside
        cout << "Calculate Current Epsilon for pcPic " << endl;
        calculateCurrentEpsilon(pcPic);
        sliding_window_length = 0;
    
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
//            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
//          m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
//                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            m_pcSliceEncoder->modifyQPActual ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);


        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        } // end while (nextCuAddr < end)
        
//        maybe a flag here! Awel haga this flag is just to do compression
//        if(isMockEncoding) {
//            cout << "compressGOP: isMockEncoding stop compressGOP in the middle " << pcSlice->getPOC() << endl;
//            return;
//        }
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        
//        cout << "\n &&&&&&&&&ACTUAL After Mock&&&&&&&&& \n" << endl;
//        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
        
        
        // Hossam: look ahead
//        cout << "CopyFromLookAhead to restore the original status of the buffer " << endl;
        m_pcSAO->copyFromLookAhead();
        
//        cout << "\n &&&&&&&&&ACTUAL After Copy&&&&&&&&& \n" << endl;
//        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
        
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    
                    
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        
//        cout << "\n &&&&&&&&&ACTUAL After Encode&&&&&&&&& \n" << endl;
//        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
        
        
        // Hossam: look ahead
//        cout << "Update LookAhead buffer with the new results " << ", at depth " << pcPic->getSlice(0)->getDepth() << endl;
        m_pcSAO->updateSAODisabledLookAhead(pcPic->getSlice(0)->getDepth());
        
//        cout << "\n &&&&&&&&&ACTUAL Update LookAhead&&&&&&&&& \n" << endl;
//        m_pcSAO->printSAOBuffer(pcPic, pcPic->getSlice(0)->getDepth());
//        m_pcSAO->printLookAheadBuffer(pcPic, pcPic->getSlice(0)->getDepth());
    
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
       
        // Hossam: LookAhead P frames
    
        // Hossam: look ahead use the actual calculate PSNR
        xCalculateAddPSNRActual( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
//        if(isAddPSNR) {
//            xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
//        }
    
    
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
    
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
    
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
    
    
        pcPic->setReconMark   ( true );
        m_bFirst = false;
    
    // Hossam: look ahead
//        m_iNumPicCoded++;
         m_iNumPicCodedActual++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
   
//    } // end for loop Gop ids shams el 3'roob
    
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
//    cout << "Mismatch ACTUAL in number of pictures coded and number of pictures rvd " << m_iNumPicCodedActual << ", " << iNumPicRcvd << endl;
    
#if IS_ENABLE_ENCODING
//    assert ( (m_iNumPicCoded == iNumPicRcvd) );
    assert ( (m_iNumPicCodedActual == iNumPicRcvd) );
#endif
    
    // Case first frame
    if(iPOCLast == 0)
    {
//        cout << "Actual Case first frame decrement coded pics in EncGOP " << endl;
        m_iNumPicCodedActual--;
    }
    
//    cout << "Set Mock numPicCoded to the actual coded " << endl;
    setNumPicCodedGOP(m_iNumPicCodedActual);
    general_GOP_id = actual_GOP_id;

    
} // end compressGOPNewP

// October 30, 2017
/////// P Frames 0 to 4
Void TEncGOP::compressGOPNewP04(TComList<TComPic *> &rcListPicYuvOrg, Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*> &rcListPic, TComList<TComPicYuv *> &rcListPicYuvRecOut, std::list<AccessUnit> &accessUnitsInGOP, Bool isField, Bool isTff, const InputColourSpaceConversion snr_conversion, const Bool printFrameMSE)
{
    
    //    cout << "Yang: TEncGOP: compressGOP Pee: NEW Yalla beena :)" << "\n" << endl;
    //    getchar();
    
    TComPic*        pcPic;
    TComPicYuv*     pcPicYuvRecOut;
    TComSlice*      pcSlice;
    TComOutputBitstream  *pcBitstreamRedirect;
    pcBitstreamRedirect = new TComOutputBitstream;
    AccessUnit::iterator  itLocationToPushSliceHeaderNALU; // used to store location where NALU containing slice header is to be inserted
    UInt                  uiOneBitstreamPerSliceLength = 0;
    TEncSbac* pcSbacCoders = NULL;
    TComOutputBitstream* pcSubstreamsOut = NULL;
    
    // Hossam: Initializing the GOP with the necessary static size is done in this method (Init GOP size)
    // Hossam: Very narrow functionality
    // GOP size static
    // isField is always sent as true --- Check the TEncTop file
    xInitGOP( iPOCLast, iNumPicRcvd, rcListPic, rcListPicYuvRecOut, isField );
    
    // SC previous & current state;
    // Hossam: It's a nice idea, but in this case
    // There won't be communication with the Entropy encoder, no Bitstream write
    // Either I save the steps (not feasible coz I will do different ME), or I skip some steps
    // as init...etc
    //    Int sc_prev_state, sc_current_state;
    
    m_iNumPicCoded = 0;
    SEIPictureTiming pictureTimingSEI;
    Bool writeSOP = m_pcCfg->getSOPDescriptionSEIEnabled();
    
    // Initialize Scalable Nesting SEI with single layer values
    SEIScalableNesting scalableNestingSEI;
    scalableNestingSEI.m_bitStreamSubsetFlag           = 1;      // If the nested SEI messages are picture buffereing SEI mesages, picure timing SEI messages or sub-picture timing SEI messages, bitstream_subset_flag shall be equal to 1
    scalableNestingSEI.m_nestingOpFlag                 = 0;
    scalableNestingSEI.m_nestingNumOpsMinus1           = 0;      //nesting_num_ops_minus1
    scalableNestingSEI.m_allLayersFlag                 = 0;
    scalableNestingSEI.m_nestingNoOpMaxTemporalIdPlus1 = 6 + 1;  //nesting_no_op_max_temporal_id_plus1
    scalableNestingSEI.m_nestingNumLayersMinus1        = 1 - 1;  //nesting_num_layers_minus1
    scalableNestingSEI.m_nestingLayerId[0]             = 0;
    scalableNestingSEI.m_callerOwnsSEIs                = true;
    
    Int picSptDpbOutputDuDelay = 0;
    UInt *accumBitsDU = NULL;
    UInt *accumNalsDU = NULL;
    SEIDecodingUnitInfo decodingUnitInfoSEI;
    
#if EFFICIENT_FIELD_IRAP
    Int IRAPGOPid = -1;
    Bool IRAPtoReorder = false;
    Bool swapIRAPForward = false;
    if(isField)
    {
        Int pocCurr;
        for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
        {
            //        cout << "Yang: TEncGOP: compressGOP: GopId--A " << (iGOPid) << " is inProgress" << "\n" << endl;
            //        getchar();
            
            // determine actual POC
            if(iPOCLast == 0) //case first frame or first top field
            {
                pocCurr=0;
            }
            else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
            {
                pocCurr = 1;
            }
            else
            {
                pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - isField;
            }
            
            // Dady: Gets the NAL unit type based on the slice type before my tweaking
            // check if POC corresponds to IRAP
            NalUnitType tmpUnitType = getNalUnitType(pocCurr, m_iLastIDR, isField);
            if(tmpUnitType >= NAL_UNIT_CODED_SLICE_BLA_W_LP && tmpUnitType <= NAL_UNIT_CODED_SLICE_CRA) // if picture is an IRAP
            {
                if(pocCurr%2 == 0 && iGOPid < m_iGopSize-1 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid+1).m_POC-1)
                { // if top field and following picture in enc order is associated bottom field
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = true;
                    break;
                }
                if(pocCurr%2 != 0 && iGOPid > 0 && m_pcCfg->getGOPEntry(iGOPid).m_POC == m_pcCfg->getGOPEntry(iGOPid-1).m_POC+1)
                {
                    // if picture is an IRAP remember to process it first
                    IRAPGOPid = iGOPid;
                    IRAPtoReorder = true;
                    swapIRAPForward = false;
                    break;
                }
            }
        }
    }
#endif
    
    
    
    // Have an attempt with a copy of rcList
    //    TComList<TComPic*> rcListPicAttempt;
    
    // loop on GOPids Until GOP size
    //    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    for ( Int iGOPid=0; iGOPid < m_iGopSize; iGOPid++ )
    {
        
        //              cout << "Yang: TEncGOP: compressGOP: GopId--B " << (iGOPid) << " is inProgress" << "\n" << endl;
        //      getchar();
        
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid = IRAPGOPid;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                }
                else if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
            }
        }
#endif
        
        UInt uiColDir = 1;
        //-- For time output for each slice
        clock_t iBeforeTime = clock();
        
        //select uiColDir
        Int iCloseLeft=1, iCloseRight=-1;
        for(Int i = 0; i<m_pcCfg->getGOPEntry(iGOPid).m_numRefPics; i++)
        {
            Int iRef = m_pcCfg->getGOPEntry(iGOPid).m_referencePics[i];
            if(iRef>0&&(iRef<iCloseRight||iCloseRight==-1))
            {
                iCloseRight=iRef;
            }
            else if(iRef<0&&(iRef>iCloseLeft||iCloseLeft==1))
            {
                iCloseLeft=iRef;
            }
        }
        if(iCloseRight>-1)
        {
            iCloseRight=iCloseRight+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
        }
        if(iCloseLeft<1)
        {
            iCloseLeft=iCloseLeft+m_pcCfg->getGOPEntry(iGOPid).m_POC-1;
            while(iCloseLeft<0)
            {
                iCloseLeft+=m_iGopSize;
            }
        }
        Int iLeftQP=0, iRightQP=0;
        for(Int i=0; i<m_iGopSize; i++)
        {
            if(m_pcCfg->getGOPEntry(i).m_POC==(iCloseLeft%m_iGopSize)+1)
            {
                iLeftQP= m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
            if (m_pcCfg->getGOPEntry(i).m_POC==(iCloseRight%m_iGopSize)+1)
            {
                iRightQP=m_pcCfg->getGOPEntry(i).m_QPOffset;
            }
        }
        if(iCloseRight>-1&&iRightQP<iLeftQP)
        {
            uiColDir=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// Initial to start encoding
        Int iTimeOffset;
        Int pocCurr;
        
        if(iPOCLast == 0) //case first frame or first top field
        {
            pocCurr=0;
            iTimeOffset = 1;
        }
        else if(iPOCLast == 1 && isField) //case first bottom field, just like the first frame, the poc computation is not right anymore, we set the right value
        {
            pocCurr = 1;
            iTimeOffset = 1;
        }
        else
        {
            pocCurr = iPOCLast - iNumPicRcvd + m_pcCfg->getGOPEntry(iGOPid).m_POC - ((isField && m_iGopSize>1) ? 1:0);
            iTimeOffset = m_pcCfg->getGOPEntry(iGOPid).m_POC;
        }
        
        cout << " POC Current22222 " << pocCurr << ", iPOCLast: " << iPOCLast << endl;
        
        if(pocCurr>=m_pcCfg->getFramesToBeEncoded())
        {
#if EFFICIENT_FIELD_IRAP
            if(IRAPtoReorder)
            {
                if(swapIRAPForward)
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid +1;
                        IRAPtoReorder = false;
                    }
                    else if(iGOPid == IRAPGOPid +1)
                    {
                        iGOPid --;
                    }
                }
                else
                {
                    if(iGOPid == IRAPGOPid)
                    {
                        iGOPid = IRAPGOPid -1;
                    }
                    else if(iGOPid == IRAPGOPid -1)
                    {
                        iGOPid = IRAPGOPid;
                        IRAPtoReorder = false;
                    }
                }
            }
#endif
            continue;
        }
        
        
        
        
        if( getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_W_RADL || getNalUnitType(pocCurr, m_iLastIDR, isField) == NAL_UNIT_CODED_SLICE_IDR_N_LP )
        {
            m_iLastIDR = pocCurr;
        }
        
        
        
        //==========================================================================================
        // start a new access unit: create an entry in the list of output access units
        accessUnitsInGOP.push_back(AccessUnit());
        AccessUnit& accessUnit = accessUnitsInGOP.back();
        
        // Hossam: Get the current pic from the list
        // Hossam: XXXX SKIP BUFFER THIS STEP
        xGetBuffer( rcListPic, rcListPicYuvRecOut, iNumPicRcvd, iTimeOffset, pcPic, pcPicYuvRecOut, pocCurr, isField );
        
        //        TComPic*        pcPicOrg;
        //        xGetBufferNew(rcListPicYuvOrg, iNumPicRcvd, iTimeOffset, pcPicOrg, pocCurr, isField);
        
        //  Slice data initialization
        pcPic->clearSliceBuffer();
        assert(pcPic->getNumAllocatedSlice() == 1);
        m_pcSliceEncoder->setSliceIdx(0);
        pcPic->setCurrSliceIdx(0);
        
        
        
        //================================Hossam==========================================================
        // Start Attempt
        
        //        samah
        // Hossam: It should be put in the initSlice due to the assignment of the B slice in the beginining of the method
        // Initialize the Slice Encoder
        //        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC() );
        
        // Hossam: Scene Change ORG
        //        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
        
        // You need to init all other SCDs with normal Qps
#if IS_YAO_SCD || IS_SASTRE_SCD || IS_DING_SCD
        m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
#else
        m_pcSliceEncoder->initEncSliceNewAttempt ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(), m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
#endif
        
        //Set Frame/Field coding
        pcSlice->getPic()->setField(isField);
        
        pcSlice->setLastIDR(m_iLastIDR);
        pcSlice->setSliceIdx(0);
        //set default slice level flag to the same as SPS level flag
        pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
        pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
        if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
        {
            m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(false);
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
        {
            pcSlice->setDefaultScalingList ();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
        {
            if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
            {
                pcSlice->setDefaultScalingList ();
            }
            pcSlice->getScalingList()->checkDcOfMatrix();
            m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
            m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
            m_pcEncTop->getTrQuant()->setUseScalingList(true);
        }
        else
        {
            printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
            assert(0);
        }
        
        
        // Hossam: Slice Type is set to P_SLICE here in compress GOP
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
        {
            pcSlice->setSliceType(P_SLICE);
        }
        if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
        {
            pcSlice->setSliceType(I_SLICE);
        }
        
        // Set the nal unit type
        pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
        if(pcSlice->getTemporalLayerNonReferenceFlag())
        {
            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_TRAIL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
            }
            if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
            {
                cout << "nalUnitType:  NAL_UNIT_CODED_SLICE_RADL_N " << endl;
                pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
            }
        }
        
#if EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
#if DELAY_SC_I==1
        // Hossam: Scene change
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
        {
            //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
            
            
            // Set the last SC happened!
            // Should be defined in states
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            
            
            // reset the select attempt process
        }
#endif
        // Do decoding refresh marking if any
        pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
        
        // Attempt with the true references in either before an SC exist or not!
        m_pcEncTop->selectReferencePictureSetNewAttempt(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
        
        //        m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
        
        //        cout << "I'm done with select " << boolalpha << (pcSlice->getRPS()==NULL) << endl;
        pcSlice->getRPS()->setNumberOfLongtermPictures(0);
        //        cout << "I'm done with after select " << endl;
        
        
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
        if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
            || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
        {
            m_associatedIRAPType = pcSlice->getNalUnitType();
            m_associatedIRAPPOC = pocCurr;
        }
        pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
        pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
        
        Bool printCheckErrors = true; // Initially false
#if ALLOW_RECOVERY_POINT_AS_RAP
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
            || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
            )
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
        }
#else
        if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
        {
            pcSlice->createExplicitReferencePictureSetFromReference(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
        }
#endif
        
        pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
        
        // Hossam: True for all
        //      cout << "SEG FAULT BEFORE "  << ", " << boolalpha << (pcSlice->getRefPic(REF_PIC_LIST_0, 0)==NULL) << endl;
        
        if(pcSlice->getTLayer() > 0
           &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                 || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
           )
        {
            if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
            {
                if(pcSlice->getTemporalLayerNonReferenceFlag())
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                }
                else
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                }
            }
            else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
            {
                Bool isSTSA=true;
                for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                {
                    Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                    if(lTid==pcSlice->getTLayer())
                    {
                        TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                        for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                        {
                            if(nRPS->getUsed(jj))
                            {
                                Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                Int kk=0;
                                for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                {
                                    if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                        break;
                                }
                                Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                if(tTid >= pcSlice->getTLayer())
                                {
                                    isSTSA=false;
                                    break;
                                }
                            }
                        }
                    }
                }
                if(isSTSA==true)
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                    }
                }
            }
        }
        arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
        TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
        refPicListModification->setRefPicListModificationFlagL0(0);
        refPicListModification->setRefPicListModificationFlagL1(0);
        pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
        
        
        //  Set reference list
        //        pcSlice->setRefPicList ( rcListPic );
        pcSlice->setRefPicList ( rcListPic );
        
        // Hossam: XXXXX I think setList1toList can be removed!
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        //  Slice info. refinement
        
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        
        //        cout << "LDC: " << pcSlice->getCheckLDC() << endl;
        
        /// >>>>>>>> IBBB-lowDelay    <<<<<<<<<
        
        
        pcSlice->setRefPOCList();
        pcSlice->setList1IdxToList0Idx();
        
        
        
        //=================================================================
        //========================ATTEMPT===================================
        //=================================================================
        // End Attempt
        
        
        //=================================================================
        //========================SC=======================================
        //=================================================================
        
        
#if IS_YAO_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeYao(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#elif IS_DING_SCD
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeDing(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        g_totalSCTime += dResult;
        
#elif IS_SASTRE_SCD
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChangeSastre(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#else
        
        // starting SC time
        Double dResult;
        clock_t lBefore = clock();
        // Hossam: 10/06/2016 --> This one is the used one
        //        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
        
        
        // Save scene change time -- hard-coded value now
#if RUN_IPPP_NOSC
        isSceneChange = false;
        
#if GET_SIGMA_ORIG
        // Get Sigma squared Origs
        m_pcEncTop->getSceneChangeCoder()->getSigmaSquaredOrig(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
        
#endif
        
#else
        isSceneChange = m_pcEncTop->getSceneChangeCoder()->isSceneChange(pcSlice->getPOC(), pcSlice, rcListPic, pcPic);
#endif
        
        if (pcSlice->getPOC() == 0 ) {
            dResult = 0;
        }
        else
            // ending SC time + total SC time
            dResult = (Double)(clock()-lBefore) / CLOCKS_PER_SEC;
        
        //        printf("\n Total SC Time: %12.3f sec.\n", dResult);
        
        // Accumlate the total SC Time
        g_totalSCTime += dResult;
        
        
#endif
        
        //#endif
        
        
        isSmooth      = m_pcEncTop->getSceneChangeCoder()->isSmooth();// Hossam: this can be only used in the state + 1, leave it for now!
        //
        //
        // NO SC, or before an SC --> Hossam XXXXX needs to get removed!
        //        if (!isSceneChange && m_pcEncTop->getSceneChangeCoder()->getLastSC() <= 0) {
        //
        //        }
        
        if(isSceneChange)
        {
            
            //                        cout << "SCEENNEEEE CHANGE BIRDDDDDDD MANNNNNN " << pocCurr << endl;
            // Reset the SC state -- Set it to zero- SC occured
            m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            // Set the last SC happened!
            m_pcEncTop -> getSceneChangeCoder() -> setLastSC(pocCurr);
            
            // Hossam: XXX I don't think this makes much difference
            //            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            //
            //            // Reset the select flags in order to avoid the mismatch in the Select process later on
            //            m_pcEncTop->resetSelectAttemptProcess();
            
            
            // if not
#if DELAY_SC_I==0
            // Hossam: XXX I don't think this makes much difference
            m_iLastRecoveryPicPOC = pcSlice->getPOC();
            
            // Reset the select flags in order to avoid the mismatch in the Select process later on
            m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
#endif
            
        }
        
        else if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
            //XXX In case Gopsize = 4;
            //            if(pocCurr == lastSc + m_iGopSize + 1)
            
            // If I'm in state 4, act as a conceptual I frame and go back to state 0
            //            if (m_pcEncTop->getSceneChangeCoder()->getSCState() == 4) {
            //                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(0);
            //            }
            
            // Hossam: Scene Change
            if(pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
#endif
                
#if DELAY_SC_I==1
                // Set the last SC happened!
                // Should be defined in states
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(4);
                
                m_iLastRecoveryPicPOC = pcSlice->getPOC();
                
                referenceSlice = isSmooth? 1:0;
                
#else
                referenceSlice = 0; // set the reference slice to 0 and not 1
#endif
                
                // Reset the select flags in order to avoid the mismatch in the Select process later on
                //                m_pcEncTop->resetSelectAttemptProcess();
                
            }
            else if(pocCurr == lastSc + m_iGopSize + 1 + referenceSlice)
            {
                
#if SC_ENABLE_PRINT_TWO
                cout << "compressGOP: STATEEEEEE ONEEEEE " << lastSc  << " " << pocCurr << endl;
#endif
                
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(1);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
                
                //                pcSlice->setRPS(pcSlice->getSPS()->getRPSList() -> getReferencePictureSet(0));
                
            }
            else if(pocCurr == lastSc + 2*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(2);
                // Adjust the references!
                //                m_pcEncTop->xInitRPSNew(isField, m_pcEncTop->getSceneChangeCoder()->getSCState());
            }
            else if(pocCurr == lastSc + 3*m_iGopSize + 1 + referenceSlice)
            {
                // Set the last SC happened!
                m_pcEncTop -> getSceneChangeCoder() -> setSCstate(3);
                
            }
            
        }
        
        //        if(isSceneChange || m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0)
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Start Executing the SC modification " << endl;
#endif
            
            // Hossam: Scene Change - QP distribution
            m_pcSliceEncoder->initEncSliceNew(pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC());
            
            //                        m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, m_pcEncTop->getSceneChangeCoder()->isSceneChange(pocCurr), m_pcEncTop->getSceneChangeCoder()->getLastSC() );
            //
            // Send the isSceneChange --> REmovesd for smooth for now
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            // Hossam: Reset the Scene change flag
            isSceneChange = false;
            
            
            //Set Frame/Field coding
            pcSlice->getPic()->setField(isField);
            
            pcSlice->setLastIDR(m_iLastIDR);
            pcSlice->setSliceIdx(0);
            //set default slice level flag to the same as SPS level flag
            pcSlice->setLFCrossSliceBoundaryFlag(  pcSlice->getPPS()->getLoopFilterAcrossSlicesEnabledFlag()  );
            pcSlice->setScalingList ( m_pcEncTop->getScalingList()  );
            if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_OFF)
            {
                m_pcEncTop->getTrQuant()->setFlatScalingList(pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(false);
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_DEFAULT)
            {
                pcSlice->setDefaultScalingList ();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else if(m_pcEncTop->getUseScalingListId() == SCALING_LIST_FILE_READ)
            {
                if(pcSlice->getScalingList()->xParseScalingList(m_pcCfg->getScalingListFile()))
                {
                    pcSlice->setDefaultScalingList ();
                }
                pcSlice->getScalingList()->checkDcOfMatrix();
                m_pcEncTop->getSPS()->setScalingListPresentFlag(pcSlice->checkDefaultScalingList());
                m_pcEncTop->getPPS()->setScalingListPresentFlag(false);
                m_pcEncTop->getTrQuant()->setScalingList(pcSlice->getScalingList(), pcSlice->getSPS()->getChromaFormatIdc());
                m_pcEncTop->getTrQuant()->setUseScalingList(true);
            }
            else
            {
                printf("error : ScalingList == %d no support\n",m_pcEncTop->getUseScalingListId());
                assert(0);
            }
            
            
            // Hossam: Setting the slice type -- Code Tweaking ENDS!!
            //=================================================================
            
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='P')
            {
                pcSlice->setSliceType(P_SLICE);
            }
            if(pcSlice->getSliceType()==B_SLICE&&m_pcCfg->getGOPEntry(iGOPid).m_sliceType=='I')
            {
                pcSlice->setSliceType(I_SLICE);
            }
            
            // Set the nal unit type
            pcSlice->setNalUnitType(getNalUnitType(pocCurr, m_iLastIDR, isField));
            
            if(pcSlice->getTemporalLayerNonReferenceFlag())
            {
                if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_TRAIL_R &&
                    !(m_iGopSize == 1 && pcSlice->getSliceType() == I_SLICE))
                    // Add this condition to avoid POC issues with encoder_intra_main.cfg configuration (see #1127 in bug tracker)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TRAIL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RADL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RADL_N);
                }
                if(pcSlice->getNalUnitType()==NAL_UNIT_CODED_SLICE_RASL_R)
                {
                    pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_RASL_N);
                }
            }
            
#if EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            // Do decoding refresh marking if any
            pcSlice->decodingRefreshMarking(m_pocCRA, m_bRefreshPending, rcListPic);
            
            // Hossam: Scene change
            // Select New
            // Send the SC state to choose the the GOP entry
            
            //            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC());
            m_pcEncTop->selectReferencePictureSetNew(pcSlice, pocCurr, iGOPid, m_pcEncTop->getSceneChangeCoder()->getSCState(), m_pcEncTop->getSceneChangeCoder()->getLastSC(), isSmooth);
            //      m_pcEncTop->selectReferencePictureSet(pcSlice, pocCurr, iGOPid);
            
            //            // Hossam: Set the new state accordingly
            //            m_pcEncTop->getSceneChangeCoder()->setSCstate(state);
            
            
            // Hossam: I don't need the SC state XXXXX
            // After selection and before check thing Modify the RC List
            // Modify the list accordingly PENDING XXXXXXX
            // I wanted to check whether there is a SC, No need ! -> The condition guarantees
            //           if(m_pcEncTop)
            pcSlice->modifyRCList(rcListPic, pcSlice->getRPS(), m_pcEncTop->getSceneChangeCoder()->getSCState());
            
            
            
            pcSlice->getRPS()->setNumberOfLongtermPictures(0);
            
            
#if DELAY_SC_I==1
            // Hossam: Scene change
            if(m_pcEncTop->getSceneChangeCoder()->getLastSC() > 0 && pocCurr == m_pcEncTop->getSceneChangeCoder()->getLastSC() + 1)
            {
                //            cout << "compressGOP: STATEEEEEE FOURRRRRRRRRRRRR ATT " << m_pcEncTop->getSceneChangeCoder()->getLastSC()  << " " << pocCurr << endl;
                // reset the select attempt process
                m_pcEncTop->resetSelectAttemptProcess(isSmooth, pocCurr);
            }
#endif
            
            // Hossam: Scene change: Reset the Smooth flag
            isSmooth = false;
            
#if !EFFICIENT_FIELD_IRAP
#if FIX1172
            if ( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_BLA_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP
                || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )  // IRAP picture
            {
                m_associatedIRAPType = pcSlice->getNalUnitType();
                m_associatedIRAPPOC = pocCurr;
            }
            pcSlice->setAssociatedIRAPType(m_associatedIRAPType);
            pcSlice->setAssociatedIRAPPOC(m_associatedIRAPPOC);
#endif
#endif
            
            
#if ALLOW_RECOVERY_POINT_AS_RAP
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors, m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3) != 0) || (pcSlice->isIRAP())
#if EFFICIENT_FIELD_IRAP
                || (isField && pcSlice->getAssociatedIRAPType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getAssociatedIRAPType() <= NAL_UNIT_CODED_SLICE_CRA && pcSlice->getAssociatedIRAPPOC() == pcSlice->getPOC()+1)
#endif
                )
            {
                /// Hossam: this one is most probably called
                // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP(), m_iLastRecoveryPicPOC, m_pcCfg->getDecodingRefreshType() == 3);
            }
#else
            // Hossam: XXXXX Removed Create Explicit from Reference in SC coding path
            //                if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
            if ((pcSlice->checkThatAllRefPicsAreAvailable(rcListPic, pcSlice->getRPS(), printCheckErrors) != 0) || (pcSlice->isIRAP()))
                
            {
                pcSlice->createExplicitReferencePictureSetFromReferenceNew(rcListPic, pcSlice->getRPS(), pcSlice->isIRAP());
            }
#endif
            
            pcSlice->applyReferencePictureSet(rcListPic, pcSlice->getRPS());
            
            
            if(pcSlice->getTLayer() > 0
               &&  !( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_N     // Check if not a leading picture
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL_R
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_N
                     || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL_R )
               )
            {
                if(pcSlice->isTemporalLayerSwitchingPoint(rcListPic) || pcSlice->getSPS()->getTemporalIdNestingFlag())
                {
                    if(pcSlice->getTemporalLayerNonReferenceFlag())
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_N);
                    }
                    else
                    {
                        pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_TSA_R);
                    }
                }
                else if(pcSlice->isStepwiseTemporalLayerSwitchingPointCandidate(rcListPic))
                {
                    Bool isSTSA=true;
                    for(Int ii=iGOPid+1;(ii<m_pcCfg->getGOPSize() && isSTSA==true);ii++)
                    {
                        Int lTid= m_pcCfg->getGOPEntry(ii).m_temporalId;
                        if(lTid==pcSlice->getTLayer())
                        {
                            TComReferencePictureSet* nRPS = pcSlice->getSPS()->getRPSList()->getReferencePictureSet(ii);
                            for(Int jj=0;jj<nRPS->getNumberOfPictures();jj++)
                            {
                                if(nRPS->getUsed(jj))
                                {
                                    Int tPoc=m_pcCfg->getGOPEntry(ii).m_POC+nRPS->getDeltaPOC(jj);
                                    Int kk=0;
                                    for(kk=0;kk<m_pcCfg->getGOPSize();kk++)
                                    {
                                        if(m_pcCfg->getGOPEntry(kk).m_POC==tPoc)
                                            break;
                                    }
                                    Int tTid=m_pcCfg->getGOPEntry(kk).m_temporalId;
                                    if(tTid >= pcSlice->getTLayer())
                                    {
                                        isSTSA=false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(isSTSA==true)
                    {
                        if(pcSlice->getTemporalLayerNonReferenceFlag())
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_N);
                        }
                        else
                        {
                            pcSlice->setNalUnitType(NAL_UNIT_CODED_SLICE_STSA_R);
                        }
                    }
                }
            }
            arrangeLongtermPicturesInRPS(pcSlice, rcListPic);
            // Hossam: XXXXX no use of this list!!!
            TComRefPicListModification* refPicListModification = pcSlice->getRefPicListModification();
            refPicListModification->setRefPicListModificationFlagL0(0);
            refPicListModification->setRefPicListModificationFlagL1(0);
            pcSlice->setNumRefIdx(REF_PIC_LIST_0,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            pcSlice->setNumRefIdx(REF_PIC_LIST_1,min(m_pcCfg->getGOPEntry(iGOPid).m_numRefPicsActive,pcSlice->getRPS()->getNumberOfPictures()));
            
        }// end if isSceneChange
        
        else// SC not working
        {
            
#if SC_ENABLE_PRINT_TWO
            cout << "Modify QP will happen now!!! " << endl;
            cout << "Modify QP will Double Initialise now!!! " << endl;
#endif
            
            
            //            // Send the isSceneChange
            //            m_pcSliceEncoder->initEncSliceNew ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField, isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
            //                                               m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
            
            
            //            m_pcSliceEncoder->initEncSlice ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField );
            m_pcSliceEncoder->modifyQP ( pcPic, iPOCLast, pocCurr, iNumPicRcvd, iGOPid, pcSlice, m_pcEncTop->getSPS(), m_pcEncTop->getPPS(), isField,       isSceneChange, m_pcEncTop->getSceneChangeCoder()->getLastSC(),
                                        m_pcEncTop->getSceneChangeCoder()->getSCState(), isSmooth);
        }// end else Scene change
        
        
        //================================Hossam==========================================================
        
        
#if ADAPTIVE_QP_SELECTION
        pcSlice->setTrQuant( m_pcEncTop->getTrQuant() );
#endif
        
        //  Set reference list
        pcSlice->setRefPicList ( rcListPic );
        
        //  Slice info. refinement
        if ( (pcSlice->getSliceType() == B_SLICE) && (pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0) )
        {
            pcSlice->setSliceType ( P_SLICE );
        }
        
        if (pcSlice->getSliceType() == B_SLICE)
        {
            pcSlice->setColFromL0Flag(1-uiColDir);
            Bool bLowDelay = true;
            Int  iCurrPOC  = pcSlice->getPOC();
            Int iRefIdx = 0;
            
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_0, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            for (iRefIdx = 0; iRefIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && bLowDelay; iRefIdx++)
            {
                if ( pcSlice->getRefPic(REF_PIC_LIST_1, iRefIdx)->getPOC() > iCurrPOC )
                {
                    bLowDelay = false;
                }
            }
            
            pcSlice->setCheckLDC(bLowDelay);
        }
        else
        {
            pcSlice->setCheckLDC(true);
        }
        
        uiColDir = 1-uiColDir;
        
        //-------------------------------------------------------------
        
        pcSlice->setRefPOCList();
        
        pcSlice->setList1IdxToList0Idx();
        
        if (m_pcEncTop->getTMVPModeId() == 2)
        {
            if (iGOPid == 0) // first picture in SOP (i.e. forward B)
            {
                pcSlice->setEnableTMVPFlag(0);
            }
            else
            {
                // Note: pcSlice->getColFromL0Flag() is assumed to be always 0 and getcolRefIdx() is always 0.
                pcSlice->setEnableTMVPFlag(1);
            }
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
        }
        else if (m_pcEncTop->getTMVPModeId() == 1)
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(1);
            pcSlice->setEnableTMVPFlag(1);
        }
        else
        {
            pcSlice->getSPS()->setTMVPFlagsPresent(0);
            pcSlice->setEnableTMVPFlag(0);
        }
        
        
        
#if IS_ENABLE_ENCODING
        /////////////////////////////////////////////////////////////////////////////////////////////////// Compress a slice
        //  Slice compression
        if (m_pcCfg->getUseASR())
        {
            m_pcSliceEncoder->setSearchRange(pcSlice);
        }
        
        Bool bGPBcheck=false;
        if ( pcSlice->getSliceType() == B_SLICE)
        {
            if ( pcSlice->getNumRefIdx(RefPicList( 0 ) ) == pcSlice->getNumRefIdx(RefPicList( 1 ) ) )
            {
                bGPBcheck=true;
                Int i;
                for ( i=0; i < pcSlice->getNumRefIdx(RefPicList( 1 ) ); i++ )
                {
                    if ( pcSlice->getRefPOC(RefPicList(1), i) != pcSlice->getRefPOC(RefPicList(0), i) )
                    {
                        bGPBcheck=false;
                        break;
                    }
                }
            }
        }
        if(bGPBcheck)
        {
            pcSlice->setMvdL1ZeroFlag(true);
        }
        else
        {
            pcSlice->setMvdL1ZeroFlag(false);
        }
        pcPic->getSlice(pcSlice->getSliceIdx())->setMvdL1ZeroFlag(pcSlice->getMvdL1ZeroFlag());
        
        Double lambda            = 0.0;
        Int actualHeadBits       = 0;
        Int actualTotalBits      = 0;
        Int estimatedBits        = 0;
        Int tmpBitsBeforeWriting = 0;
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Int frameLevel = m_pcRateCtrl->getRCSeq()->getGOPID2Level( iGOPid );
            if ( pcPic->getSlice(0)->getSliceType() == I_SLICE )
            {
                frameLevel = 0;
            }
            m_pcRateCtrl->initRCPic( frameLevel );
            estimatedBits = m_pcRateCtrl->getRCPic()->getTargetBits();
            
            Int sliceQP = m_pcCfg->getInitialQP();
            if ( ( pcSlice->getPOC() == 0 && m_pcCfg->getInitialQP() > 0 ) || ( frameLevel == 0 && m_pcCfg->getForceIntraQP() ) ) // QP is specified
            {
                Int    NumberBFrames = ( m_pcCfg->getGOPSize() - 1 );
                Double dLambda_scale = 1.0 - Clip3( 0.0, 0.5, 0.05*(Double)NumberBFrames );
                Double dQPFactor     = 0.57*dLambda_scale;
                Int    SHIFT_QP      = 12;
                Int    bitdepth_luma_qp_scale = 0;
                Double qp_temp = (Double) sliceQP + bitdepth_luma_qp_scale - SHIFT_QP;
                lambda = dQPFactor*pow( 2.0, qp_temp/3.0 );
            }
            else if ( frameLevel == 0 )   // intra case, but use the model
            {
                m_pcSliceEncoder->calCostSliceI(pcPic);
                
                if ( m_pcCfg->getIntraPeriod() != 1 )   // do not refine allocated bits for all intra case
                {
                    Int bits = m_pcRateCtrl->getRCSeq()->getLeftAverageBits();
                    bits = m_pcRateCtrl->getRCPic()->getRefineBitsForIntra( bits );
                    if ( bits < 200 )
                    {
                        bits = 200;
                    }
                    m_pcRateCtrl->getRCPic()->setTargetBits( bits );
                }
                
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                m_pcRateCtrl->getRCPic()->getLCUInitTargetBits();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            else    // normal case
            {
                list<TEncRCPic*> listPreviousPicture = m_pcRateCtrl->getPicList();
                lambda  = m_pcRateCtrl->getRCPic()->estimatePicLambda( listPreviousPicture, pcSlice->getSliceType());
                sliceQP = m_pcRateCtrl->getRCPic()->estimatePicQP( lambda, listPreviousPicture );
            }
            
            sliceQP = Clip3( -pcSlice->getSPS()->getQpBDOffset(CHANNEL_TYPE_LUMA), MAX_QP, sliceQP );
            m_pcRateCtrl->getRCPic()->setPicEstQP( sliceQP );
            
            m_pcSliceEncoder->resetQP( pcPic, sliceQP, lambda );
        }
        
        UInt uiNumSlices = 1;
        
        UInt uiInternalAddress = pcPic->getNumPartInCU()-4;
        UInt uiExternalAddress = pcPic->getPicSym()->getNumberOfCUsInFrame()-1;
        UInt uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        UInt uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
        UInt uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
        while(uiPosX>=uiWidth||uiPosY>=uiHeight)
        {
            uiInternalAddress--;
            uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
            uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
        }
        uiInternalAddress++;
        if(uiInternalAddress==pcPic->getNumPartInCU())
        {
            uiInternalAddress = 0;
            uiExternalAddress++;
        }
        UInt uiRealEndAddress = uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress;
        
        Int  p, j;
        UInt uiEncCUAddr;
        
        pcPic->getPicSym()->initTiles(pcSlice->getPPS());
        
        // Allocate some coders, now we know how many tiles there are.
        const Int iNumSubstreams = pcSlice->getPPS()->getNumSubstreams();
        
        //generate the Coding Order Map and Inverse Coding Order Map
        for(p=0, uiEncCUAddr=0; p<pcPic->getPicSym()->getNumberOfCUsInFrame(); p++, uiEncCUAddr = pcPic->getPicSym()->xCalculateNxtCUAddr(uiEncCUAddr))
        {
            pcPic->getPicSym()->setCUOrderMap(p, uiEncCUAddr);
            pcPic->getPicSym()->setInverseCUOrderMap(uiEncCUAddr, p);
        }
        pcPic->getPicSym()->setCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        pcPic->getPicSym()->setInverseCUOrderMap(pcPic->getPicSym()->getNumberOfCUsInFrame(), pcPic->getPicSym()->getNumberOfCUsInFrame());
        
        // Allocate some coders, now we know how many tiles there are.
        m_pcEncTop->createWPPCoders(iNumSubstreams);
        pcSbacCoders = m_pcEncTop->getSbacCoders();
        pcSubstreamsOut = new TComOutputBitstream[iNumSubstreams];
        
        UInt startCUAddrSliceIdx = 0; // used to index "m_uiStoredStartCUAddrForEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSlice    = 0; // used to keep track of current slice's starting CU addr.
        pcSlice->setSliceCurStartCUAddr( startCUAddrSlice ); // Setting "start CU addr" for current slice
        m_storedStartCUAddrForEncodingSlice.clear();
        
        UInt startCUAddrSliceSegmentIdx = 0; // used to index "m_uiStoredStartCUAddrForEntropyEncodingSlice" containing locations of slice boundaries
        UInt startCUAddrSliceSegment    = 0; // used to keep track of current Dependent slice's starting CU addr.
        pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment ); // Setting "start CU addr" for current Dependent slice
        
        m_storedStartCUAddrForEncodingSliceSegment.clear();
        UInt nextCUAddr = 0;
        m_storedStartCUAddrForEncodingSlice.push_back (nextCUAddr);
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(nextCUAddr);
        startCUAddrSliceSegmentIdx++;
        
        
        while(nextCUAddr<uiRealEndAddress) // determine slice boundaries
        {
            pcSlice->setNextSlice       ( false );
            pcSlice->setNextSliceSegment( false );
            assert(pcPic->getNumAllocatedSlice() == startCUAddrSliceIdx);
            m_pcSliceEncoder->precompressSlice( pcPic );
            
            // Hossam: Compress Slice
            m_pcSliceEncoder->compressSlice   ( pcPic );
            //            cout << "Ack Done with Compress Slice " << endl;
            
            Bool bNoBinBitConstraintViolated = (!pcSlice->isNextSlice() && !pcSlice->isNextSliceSegment());
            if (pcSlice->isNextSlice() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSlice = pcSlice->getSliceCurEndCUAddr();
                // Reconstruction slice
                m_storedStartCUAddrForEncodingSlice.push_back(startCUAddrSlice);
                startCUAddrSliceIdx++;
                // Dependent slice
                if (startCUAddrSliceSegmentIdx>0 && m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx-1] != startCUAddrSlice)
                {
                    m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSlice);
                    startCUAddrSliceSegmentIdx++;
                }
                
                if (startCUAddrSlice < uiRealEndAddress)
                {
                    pcPic->allocateNewSlice();
                    pcPic->setCurrSliceIdx                  ( startCUAddrSliceIdx-1 );
                    m_pcSliceEncoder->setSliceIdx           ( startCUAddrSliceIdx-1 );
                    pcSlice = pcPic->getSlice               ( startCUAddrSliceIdx-1 );
                    pcSlice->copySliceInfo                  ( pcPic->getSlice(0)      );
                    pcSlice->setSliceIdx                    ( startCUAddrSliceIdx-1 );
                    pcSlice->setSliceCurStartCUAddr         ( startCUAddrSlice      );
                    pcSlice->setSliceSegmentCurStartCUAddr  ( startCUAddrSlice      );
                    pcSlice->setSliceBits(0);
                    uiNumSlices ++;
                }
            }
            else if (pcSlice->isNextSliceSegment() || (bNoBinBitConstraintViolated && m_pcCfg->getSliceSegmentMode()==FIXED_NUMBER_OF_LCU))
            {
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
                m_storedStartCUAddrForEncodingSliceSegment.push_back(startCUAddrSliceSegment);
                startCUAddrSliceSegmentIdx++;
                pcSlice->setSliceSegmentCurStartCUAddr( startCUAddrSliceSegment );
            }
            else
            {
                startCUAddrSlice                                                            = pcSlice->getSliceCurEndCUAddr();
                startCUAddrSliceSegment                                                     = pcSlice->getSliceSegmentCurEndCUAddr();
            }
            
            nextCUAddr = (startCUAddrSlice > startCUAddrSliceSegment) ? startCUAddrSlice : startCUAddrSliceSegment;
        }
        
        
        m_storedStartCUAddrForEncodingSlice.push_back( pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceIdx++;
        m_storedStartCUAddrForEncodingSliceSegment.push_back(pcSlice->getSliceCurEndCUAddr());
        startCUAddrSliceSegmentIdx++;
        
        pcSlice = pcPic->getSlice(0);
        
        // SAO parameter estimation using non-deblocked pixels for LCU bottom and right boundary areas
        if( pcSlice->getSPS()->getUseSAO() && m_pcCfg->getSaoLcuBoundary() )
        {
            m_pcSAO->getPreDBFStatistics(pcPic);
        }
        
        //-- Loop filter
        Bool bLFCrossTileBoundary = pcSlice->getPPS()->getLoopFilterAcrossTilesEnabledFlag();
        m_pcLoopFilter->setCfg(bLFCrossTileBoundary);
        if ( m_pcCfg->getDeblockingFilterMetric() )
        {
            dblMetric(pcPic, uiNumSlices);
        }
        m_pcLoopFilter->loopFilterPic( pcPic );
        
        /////////////////////////////////////////////////////////////////////////////////////////////////// File writing
        // Set entropy coder
        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
        
        /* write various header sets. */
        //    if ( m_bSeqFirst )
        // Hossam SCENE CHANGE SPS
        //      Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 9
        //                        || pcSlice->getPOC() == 13 || pcSlice->getPOC() == 17;
        
        
        // Hossam: SC should be IRAP  XXXXXX
        //        Bool isSceneChange = pcSlice->getPOC() == 5 || pcSlice->getPOC() == 10
        //        || pcSlice->getPOC() == 14 || pcSlice->getPOC() == 18;
        //
        //        Int lastSc = m_pcEncTop->getSceneChangeCoder()->getLastSC();
        //
        //        Bool isSceneChange = pcSlice->getPOC()  == lastSc + 0*m_iGopSize + 0||
        //        pcSlice->getPOC() == lastSc + 1*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 2*m_iGopSize + 1 ||
        //        pcSlice->getPOC() == lastSc + 3*m_iGopSize + 1;
        //
        
        //        if ( m_bSeqFirst || isSceneChange )
        if ( m_bSeqFirst )
        {
            //            cout << "Menna El Kashef: Change SPS for the SC and First frame!" << endl;
            
            OutputNALUnit nalu(NAL_UNIT_VPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodeVPS(m_pcEncTop->getVPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_SPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            if (m_bSeqFirst)
            {
                pcSlice->getSPS()->setNumLongTermRefPicSPS(m_numLongTermRefPicSPS);
                assert (m_numLongTermRefPicSPS <= MAX_NUM_LONG_TERM_REF_PICS);
                for (Int k = 0; k < m_numLongTermRefPicSPS; k++)
                {
                    pcSlice->getSPS()->setLtRefPicPocLsbSps(k, m_ltRefPicPocLsbSps[k]);
                    pcSlice->getSPS()->setUsedByCurrPicLtSPSFlag(k, m_ltRefPicUsedByCurrPicFlag[k]);
                }
            }
            if( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                UInt maxCU = m_pcCfg->getSliceArgument() >> ( pcSlice->getSPS()->getMaxCUDepth() << 1);
                UInt numDU = ( m_pcCfg->getSliceMode() == 1 ) ? ( pcPic->getNumCUsInFrame() / maxCU ) : ( 0 );
                if( pcPic->getNumCUsInFrame() % maxCU != 0 || numDU == 0 )
                {
                    numDU ++;
                }
                pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->setNumDU( numDU );
                pcSlice->getSPS()->setHrdParameters( m_pcCfg->getFrameRate(), numDU, m_pcCfg->getTargetBitrate(), ( m_pcCfg->getIntraPeriod() > 0 ) );
            }
            if( m_pcCfg->getBufferingPeriodSEIEnabled() || m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                pcSlice->getSPS()->getVuiParameters()->setHrdParametersPresentFlag( true );
            }
            m_pcEntropyCoder->encodeSPS(pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            nalu = NALUnit(NAL_UNIT_PPS);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            m_pcEntropyCoder->encodePPS(pcSlice->getPPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
            
            xCreateLeadingSEIMessages(accessUnit, pcSlice->getSPS());
            
            
            m_bSeqFirst = false;
        }
        
        if (writeSOP) // write SOP description SEI (if enabled) at the beginning of GOP
        {
            Int SOPcurrPOC = pocCurr;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEISOPDescription SOPDescriptionSEI;
            SOPDescriptionSEI.m_sopSeqParameterSetId = pcSlice->getSPS()->getSPSId();
            
            UInt i = 0;
            UInt prevEntryId = iGOPid;
            for (j = iGOPid; j < m_iGopSize; j++)
            {
                Int deltaPOC = m_pcCfg->getGOPEntry(j).m_POC - m_pcCfg->getGOPEntry(prevEntryId).m_POC;
                if ((SOPcurrPOC + deltaPOC) < m_pcCfg->getFramesToBeEncoded())
                {
                    SOPcurrPOC += deltaPOC;
                    SOPDescriptionSEI.m_sopDescVclNaluType[i] = getNalUnitType(SOPcurrPOC, m_iLastIDR, isField);
                    SOPDescriptionSEI.m_sopDescTemporalId[i] = m_pcCfg->getGOPEntry(j).m_temporalId;
                    SOPDescriptionSEI.m_sopDescStRpsIdx[i] = m_pcEncTop->getReferencePictureSetIdxForSOP(pcSlice, SOPcurrPOC, j);
                    SOPDescriptionSEI.m_sopDescPocDelta[i] = deltaPOC;
                    
                    prevEntryId = j;
                    i++;
                }
            }
            
            SOPDescriptionSEI.m_numPicsInSopMinus1 = i - 1;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, SOPDescriptionSEI, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
            
            writeSOP = false;
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            if( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() )
            {
                UInt numDU = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNumDU();
                pictureTimingSEI.m_numDecodingUnitsMinus1     = ( numDU - 1 );
                pictureTimingSEI.m_duCommonCpbRemovalDelayFlag = false;
                
                if( pictureTimingSEI.m_numNalusInDuMinus1 == NULL )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1       = new UInt[ numDU ];
                }
                if( pictureTimingSEI.m_duCpbRemovalDelayMinus1  == NULL )
                {
                    pictureTimingSEI.m_duCpbRemovalDelayMinus1  = new UInt[ numDU ];
                }
                if( accumBitsDU == NULL )
                {
                    accumBitsDU                                  = new UInt[ numDU ];
                }
                if( accumNalsDU == NULL )
                {
                    accumNalsDU                                  = new UInt[ numDU ];
                }
            }
            pictureTimingSEI.m_auCpbRemovalDelay = std::min<Int>(std::max<Int>(1, m_totalCoded - m_lastBPSEI), static_cast<Int>(pow(2, static_cast<Double>(pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getCpbRemovalDelayLengthMinus1()+1)))); // Syntax element signalled as minus, hence the .
            pictureTimingSEI.m_picDpbOutputDelay = pcSlice->getSPS()->getNumReorderPics(pcSlice->getSPS()->getMaxTLayers()-1) + pcSlice->getPOC() - m_totalCoded;
#if EFFICIENT_FIELD_IRAP
            if(IRAPGOPid > 0 && IRAPGOPid < m_iGopSize)
            {
                // if pictures have been swapped there is likely one more picture delay on their tid. Very rough approximation
                pictureTimingSEI.m_picDpbOutputDelay ++;
            }
#endif
            Int factor = pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2;
            pictureTimingSEI.m_picDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() )
            {
                picSptDpbOutputDuDelay = factor * pictureTimingSEI.m_picDpbOutputDelay;
            }
        }
        
        if( ( m_pcCfg->getBufferingPeriodSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIBufferingPeriod sei_buffering_period;
            
            UInt uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
            sei_buffering_period.m_initialCpbRemovalDelay      [0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][0]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelay      [0][1]     = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialCpbRemovalDelayOffset[0][1]     = uiInitialCpbRemovalDelay;
            
            Double dTmp = (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getNumUnitsInTick() / (Double)pcSlice->getSPS()->getVuiParameters()->getTimingInfo()->getTimeScale();
            
            UInt uiTmp = (UInt)( dTmp * 90000.0 );
            uiInitialCpbRemovalDelay -= uiTmp;
            uiInitialCpbRemovalDelay -= uiTmp / ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getTickDivisorMinus2() + 2 );
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][0]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelay      [0][1]  = uiInitialCpbRemovalDelay;
            sei_buffering_period.m_initialAltCpbRemovalDelayOffset[0][1]  = uiInitialCpbRemovalDelay;
            
            sei_buffering_period.m_rapCpbParamsPresentFlag              = 0;
            //for the concatenation, it can be set to one during splicing.
            sei_buffering_period.m_concatenationFlag = 0;
            //since the temporal layer HRD is not ready, we assumed it is fixed
            sei_buffering_period.m_auCpbRemovalDelayDelta = 1;
            
            sei_buffering_period.m_cpbDelayOffset = 0;
            sei_buffering_period.m_dpbDelayOffset = 0;
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_buffering_period, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            {
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU;   // Insert BP SEI after APS SEI
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(nalu));
                m_bufferingPeriodSEIPresentInAU = true;
            }
            
            if (m_pcCfg->getScalableNestingSEIEnabled())
            {
                OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
                scalableNestingSEI.m_nestedSEIs.clear();
                scalableNestingSEI.m_nestedSEIs.push_back(&sei_buffering_period);
                m_seiWriter.writeSEImessage( naluTmp.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                writeRBSPTrailingBits(naluTmp.m_Bitstream);
                UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                UInt offsetPosition = m_activeParameterSetSEIPresentInAU + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU;   // Insert BP SEI after non-nested APS, BP and PT SEIs
                AccessUnit::iterator it;
                for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                {
                    it++;
                }
                accessUnit.insert(it, new NALUnitEBSP(naluTmp));
                m_nestedBufferingPeriodSEIPresentInAU = true;
            }
            
            m_lastBPSEI = m_totalCoded;
            m_cpbRemovalDelay = 0;
        }
        m_cpbRemovalDelay ++;
        
        if(pcSlice->getSPS()->getVuiParametersPresentFlag() && m_pcCfg->getChromaSamplingFilterHintEnabled() && ( pcSlice->getSliceType() == I_SLICE ))
        {
            SEIChromaSamplingFilterHint *seiChromaSamplingFilterHint = xCreateSEIChromaSamplingFilterHint(m_pcCfg->getChromaLocInfoPresentFlag(), m_pcCfg->getChromaSamplingHorFilterIdc(), m_pcCfg->getChromaSamplingVerFilterIdc());
            
            OutputNALUnit naluTmp(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&naluTmp.m_Bitstream);
            m_seiWriter.writeSEImessage(naluTmp.m_Bitstream, *seiChromaSamplingFilterHint, pcSlice->getSPS());
            writeRBSPTrailingBits(naluTmp.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(naluTmp));
            delete seiChromaSamplingFilterHint;
        }
        
        if( ( m_pcEncTop->getRecoveryPointSEIEnabled() ) && ( pcSlice->getSliceType() == I_SLICE ) )
        {
            if( m_pcEncTop->getGradualDecodingRefreshInfoEnabled() && !pcSlice->getRapPicFlag() )
            {
                // Gradual decoding refresh SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEIGradualDecodingRefreshInfo seiGradualDecodingRefreshInfo;
                seiGradualDecodingRefreshInfo.m_gdrForegroundFlag = true; // Indicating all "foreground"
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiGradualDecodingRefreshInfo, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
            // Recovery point SEI
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
            
            SEIRecoveryPoint sei_recovery_point;
            sei_recovery_point.m_recoveryPocCnt    = 0;
            sei_recovery_point.m_exactMatchingFlag = ( pcSlice->getPOC() == 0 ) ? (true) : (false);
            sei_recovery_point.m_brokenLinkFlag    = false;
#if ALLOW_RECOVERY_POINT_AS_RAP
            if(m_pcCfg->getDecodingRefreshType() == 3)
            {
                m_iLastRecoveryPicPOC = pocCurr;
            }
#endif
            
            m_seiWriter.writeSEImessage( nalu.m_Bitstream, sei_recovery_point, pcSlice->getSPS() );
            writeRBSPTrailingBits(nalu.m_Bitstream);
            accessUnit.push_back(new NALUnitEBSP(nalu));
        }
        
        if( m_pcEncTop->getNoDisplaySEITLayer() )
        {
            if( pcSlice->getTLayer() >= m_pcEncTop->getNoDisplaySEITLayer() )
            {
                // No display SEI
                OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                
                SEINoDisplay seiNoDisplay;
                seiNoDisplay.m_noDisplay = true;
                
                m_seiWriter.writeSEImessage( nalu.m_Bitstream, seiNoDisplay, pcSlice->getSPS() );
                writeRBSPTrailingBits(nalu.m_Bitstream);
                accessUnit.push_back(new NALUnitEBSP(nalu));
            }
        }
        
        /* use the main bitstream buffer for storing the marshalled picture */
        m_pcEntropyCoder->setBitstream(NULL);
        
        startCUAddrSliceIdx = 0;
        startCUAddrSlice    = 0;
        
        startCUAddrSliceSegmentIdx = 0;
        startCUAddrSliceSegment    = 0;
        nextCUAddr                 = 0;
        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
        
        Int processingState = (pcSlice->getSPS()->getUseSAO())?(EXECUTE_INLOOPFILTER):(ENCODE_SLICE);
        Bool skippedSlice=false;
        while (nextCUAddr < uiRealEndAddress) // Iterate over all slices
        {
            switch(processingState) // NOTE: RExt - the indentation in this switch statement needs updating.
            {
                case ENCODE_SLICE:
                {
                    pcSlice->setNextSlice       ( false );
                    pcSlice->setNextSliceSegment( false );
                    if (nextCUAddr == m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx])
                    {
                        pcSlice = pcPic->getSlice(startCUAddrSliceIdx);
                        if(startCUAddrSliceIdx > 0 && pcSlice->getSliceType()!= I_SLICE)
                        {
                            pcSlice->checkColRefIdx(startCUAddrSliceIdx, pcPic);
                        }
                        pcPic->setCurrSliceIdx(startCUAddrSliceIdx);
                        m_pcSliceEncoder->setSliceIdx(startCUAddrSliceIdx);
                        assert(startCUAddrSliceIdx == pcSlice->getSliceIdx());
                        // Reconstruction slice
                        pcSlice->setSliceCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceCurEndCUAddr  ( m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx+1 ] );
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSlice       ( true );
                        
                        startCUAddrSliceIdx++;
                        startCUAddrSliceSegmentIdx++;
                    }
                    else if (nextCUAddr == m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx])
                    {
                        // Dependent slice
                        pcSlice->setSliceSegmentCurStartCUAddr( nextCUAddr );  // to be used in encodeSlice() + context restriction
                        pcSlice->setSliceSegmentCurEndCUAddr  ( m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx+1 ] );
                        
                        pcSlice->setNextSliceSegment( true );
                        
                        startCUAddrSliceSegmentIdx++;
                    }
                    
                    pcSlice->setRPS(pcPic->getSlice(0)->getRPS());
                    pcSlice->setRPSidx(pcPic->getSlice(0)->getRPSidx());
                    UInt uiDummyStartCUAddr;
                    UInt uiDummyBoundingCUAddr;
                    m_pcSliceEncoder->xDetermineStartAndBoundingCUAddr(uiDummyStartCUAddr,uiDummyBoundingCUAddr,pcPic,true);
                    
                    uiInternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) % pcPic->getNumPartInCU();
                    uiExternalAddress = pcPic->getPicSym()->getPicSCUAddr(pcSlice->getSliceSegmentCurEndCUAddr()-1) / pcPic->getNumPartInCU();
                    uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    uiWidth = pcSlice->getSPS()->getPicWidthInLumaSamples();
                    uiHeight = pcSlice->getSPS()->getPicHeightInLumaSamples();
                    while(uiPosX>=uiWidth||uiPosY>=uiHeight)
                    {
                        uiInternalAddress--;
                        uiPosX = ( uiExternalAddress % pcPic->getFrameWidthInCU() ) * g_uiMaxCUWidth+ g_auiRasterToPelX[ g_auiZscanToRaster[uiInternalAddress] ];
                        uiPosY = ( uiExternalAddress / pcPic->getFrameWidthInCU() ) * g_uiMaxCUHeight+ g_auiRasterToPelY[ g_auiZscanToRaster[uiInternalAddress] ];
                    }
                    uiInternalAddress++;
                    if(uiInternalAddress==pcPic->getNumPartInCU())
                    {
                        uiInternalAddress = 0;
                        uiExternalAddress = pcPic->getPicSym()->getCUOrderMap(pcPic->getPicSym()->getInverseCUOrderMap(uiExternalAddress)+1);
                    }
                    UInt endAddress = pcPic->getPicSym()->getPicSCUEncOrder(uiExternalAddress*pcPic->getNumPartInCU()+uiInternalAddress);
                    if(endAddress<=pcSlice->getSliceSegmentCurStartCUAddr())
                    {
                        UInt boundingAddrSlice, boundingAddrSliceSegment;
                        boundingAddrSlice          = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                        boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                        nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                        if(pcSlice->isNextSlice())
                        {
                            skippedSlice=true;
                        }
                        continue;
                    }
                    if(skippedSlice)
                    {
                        pcSlice->setNextSlice       ( true );
                        pcSlice->setNextSliceSegment( false );
                    }
                    skippedSlice=false;
                    pcSlice->allocSubstreamSizes( iNumSubstreams );
                    for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                    {
                        pcSubstreamsOut[ui].clear();
                    }
                    
                    m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                    m_pcEntropyCoder->resetEntropy      ();
                    /* start slice NALunit */
                    OutputNALUnit nalu( pcSlice->getNalUnitType(), pcSlice->getTLayer() );
                    Bool sliceSegment = (!pcSlice->isNextSlice());
                    if (!sliceSegment)
                    {
                        uiOneBitstreamPerSliceLength = 0; // start of a new slice
                    }
                    m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                    
#if SETTING_NO_OUT_PIC_PRIOR
                    pcSlice->setNoRaslOutputFlag(false);
                    if (pcSlice->isIRAP())
                    {
                        if (pcSlice->getNalUnitType() >= NAL_UNIT_CODED_SLICE_BLA_W_LP && pcSlice->getNalUnitType() <= NAL_UNIT_CODED_SLICE_IDR_N_LP)
                        {
                            pcSlice->setNoRaslOutputFlag(true);
                        }
                        //the inference for NoOutputPriorPicsFlag
                        // KJS: This cannot happen at the encoder
                        if (!m_bFirst && pcSlice->isIRAP() && pcSlice->getNoRaslOutputFlag())
                        {
                            if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
                            {
                                pcSlice->setNoOutputPriorPicsFlag(true);
                            }
                        }
                    }
#endif
                    
                    tmpBitsBeforeWriting = m_pcEntropyCoder->getNumberOfWrittenBits();
                    m_pcEntropyCoder->encodeSliceHeader(pcSlice);
                    actualHeadBits += ( m_pcEntropyCoder->getNumberOfWrittenBits() - tmpBitsBeforeWriting );
                    
                    // is it needed?
                    {
                        if (!sliceSegment)
                        {
                            pcBitstreamRedirect->writeAlignOne();
                        }
                        else
                        {
                            // We've not completed our slice header info yet, do the alignment later.
                        }
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                        m_pcEntropyCoder->resetEntropy    ();
                        for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                        {
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->resetEntropy    ();
                        }
                    }
                    
                    if(pcSlice->isNextSlice())
                    {
                        // set entropy coder for writing
                        m_pcSbacCoder->init( (TEncBinIf*)m_pcBinCABAC );
                        {
                            for ( UInt ui = 0 ; ui < iNumSubstreams ; ui++ )
                            {
                                m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[ui], pcSlice );
                                m_pcEntropyCoder->resetEntropy    ();
                            }
                            pcSbacCoders[0].load(m_pcSbacCoder);
                            m_pcEntropyCoder->setEntropyCoder ( &pcSbacCoders[0], pcSlice );  //ALF is written in substream #0 with CABAC coder #0 (see ALF param encoding below)
                        }
                        m_pcEntropyCoder->resetEntropy    ();
                        // File writing
                        if (!sliceSegment)
                        {
                            m_pcEntropyCoder->setBitstream(pcBitstreamRedirect);
                        }
                        else
                        {
                            m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        }
                        // for now, override the TILES_DECODER setting in order to write substreams.
                        m_pcEntropyCoder->setBitstream    ( &pcSubstreamsOut[0] );
                        
                    }
                    pcSlice->setFinalized(true);
                    
                    m_pcSbacCoder->load( &pcSbacCoders[0] );
                    
                    pcSlice->setTileOffstForMultES( uiOneBitstreamPerSliceLength );
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = true;
#endif
                    
                    pcSlice->setTileLocationCount ( 0 );
                    m_pcSliceEncoder->encodeSlice(pcPic, pcSubstreamsOut);
                    
#if RExt__ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
                    g_bFinalEncode = false;
#endif
                    
                    {
                        // Construct the final bitstream by flushing and concatenating substreams.
                        // The final bitstream is either nalu.m_Bitstream or pcBitstreamRedirect;
                        UInt* puiSubstreamSizes = pcSlice->getSubstreamSizes();
                        UInt uiTotalCodedSize = 0; // for padding calcs.
                        UInt uiNumSubstreamsPerTile = iNumSubstreams; // Only used if wavefronts not enabled.
                        if (iNumSubstreams > 1)
                        {
                            uiNumSubstreamsPerTile /= pcPic->getPicSym()->getNumTiles(); // Only used if wavefronts not enabled.
                        }
                        for ( UInt ui = 0 ; ui < iNumSubstreams; ui++ )
                        {
                            // Flush all substreams -- this includes empty ones.
                            // Terminating bit and flush.
                            m_pcEntropyCoder->setEntropyCoder   ( &pcSbacCoders[ui], pcSlice );
                            m_pcEntropyCoder->setBitstream      (  &pcSubstreamsOut[ui] );
                            m_pcEntropyCoder->encodeTerminatingBit( 1 );
                            m_pcEntropyCoder->encodeSliceFinish();
                            
                            pcSubstreamsOut[ui].writeByteAlignment();   // Byte-alignment in slice_data() at end of sub-stream
                            // Byte alignment is necessary between tiles when tiles are independent.
                            uiTotalCodedSize += pcSubstreamsOut[ui].getNumberOfWrittenBits();
                            
                            Bool bNextSubstreamInNewTile = ((ui+1) < iNumSubstreams)&& ((ui+1)%uiNumSubstreamsPerTile == 0);
                            if (bNextSubstreamInNewTile &&  !pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag() )
                            {
                                pcSlice->setTileLocation(ui/uiNumSubstreamsPerTile, pcSlice->getTileOffstForMultES()+(uiTotalCodedSize>>3));
                            }
                            if (ui+1 < iNumSubstreams)
                            {
                                puiSubstreamSizes[ui] = pcSubstreamsOut[ui].getNumberOfWrittenBits() + (pcSubstreamsOut[ui].countStartCodeEmulations()<<3);
                            }
                        }
                        
                        // Complete the slice header info.
                        m_pcEntropyCoder->setEntropyCoder   ( m_pcCavlcCoder, pcSlice );
                        m_pcEntropyCoder->setBitstream(&nalu.m_Bitstream);
                        m_pcEntropyCoder->encodeTilesWPPEntryPoint( pcSlice );
                        
                        // Substreams...
                        TComOutputBitstream *pcOut = pcBitstreamRedirect;
                        Int numZeroSubstreamsAtStartOfSlice = 0;
                        Int numSubstreamsToCode = pcSlice->getPPS()->getNumSubstreams();
                        if (pcSlice->getPPS()->getEntropyCodingSyncEnabledFlag())
                        {
                            Int  maxNumParts                      = pcPic->getNumPartInCU();
                            numZeroSubstreamsAtStartOfSlice  = pcPic->getSubstreamForLCUAddr(pcSlice->getSliceSegmentCurStartCUAddr()/maxNumParts, false, pcSlice);
                            // 1st line present for WPP.
                            numSubstreamsToCode  = pcSlice->getNumEntryPointOffsets()+1;
                        }
                        for ( UInt ui = 0 ; ui < numSubstreamsToCode; ui++ )
                        {
                            pcOut->addSubstream(&pcSubstreamsOut[ui+numZeroSubstreamsAtStartOfSlice]);
                        }
                    }
                    
                    UInt boundingAddrSlice, boundingAddrSliceSegment;
                    boundingAddrSlice        = m_storedStartCUAddrForEncodingSlice[startCUAddrSliceIdx];
                    boundingAddrSliceSegment = m_storedStartCUAddrForEncodingSliceSegment[startCUAddrSliceSegmentIdx];
                    nextCUAddr               = min(boundingAddrSlice, boundingAddrSliceSegment);
                    // If current NALU is the first NALU of slice (containing slice header) and more NALUs exist (due to multiple dependent slices) then buffer it.
                    // If current NALU is the last NALU of slice and a NALU was buffered, then (a) Write current NALU (b) Update an write buffered NALU at approproate location in NALU list.
                    Bool bNALUAlignedWrittenToList    = false; // used to ensure current NALU is not written more than once to the NALU list.
                    xAttachSliceDataToNalUnit(nalu, pcBitstreamRedirect);
                    accessUnit.push_back(new NALUnitEBSP(nalu));
                    actualTotalBits += UInt(accessUnit.back()->m_nalUnitData.str().size()) * 8;
                    bNALUAlignedWrittenToList = true;
                    uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits(); // length of bitstream after byte-alignment
                    
                    if (!bNALUAlignedWrittenToList)
                    {
                        {
                            nalu.m_Bitstream.writeAlignZero();
                        }
                        accessUnit.push_back(new NALUnitEBSP(nalu));
                        uiOneBitstreamPerSliceLength += nalu.m_Bitstream.getNumberOfWrittenBits() + 24; // length of bitstream after byte-alignment + 3 byte startcode 0x000001
                    }
                    
                    if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
                       ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
                       ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
                        || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) &&
                       ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getSubPicCpbParamsPresentFlag() ) )
                    {
                        UInt numNalus = 0;
                        UInt numRBSPBytes = 0;
                        for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                numRBSPBytes += numRBSPBytes_nal;
                                numNalus ++;
                            }
                        }
                        accumBitsDU[ pcSlice->getSliceIdx() ] = ( numRBSPBytes << 3 );
                        accumNalsDU[ pcSlice->getSliceIdx() ] = numNalus;   // SEI not counted for bit count; hence shouldn't be counted for # of NALUs - only for consistency
                    }
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                case EXECUTE_INLOOPFILTER:
                {
                    // set entropy coder for RD
                    m_pcEntropyCoder->setEntropyCoder ( m_pcSbacCoder, pcSlice );
                    if ( pcSlice->getSPS()->getUseSAO() )
                    {
                        m_pcEntropyCoder->resetEntropy();
                        m_pcEntropyCoder->setBitstream( m_pcBitCounter );
                        Bool sliceEnabled[MAX_NUM_COMPONENT];
                        m_pcSAO->initRDOCabacCoder(m_pcEncTop->getRDGoOnSbacCoder(), pcSlice);
                        m_pcSAO->SAOProcess(pcPic
                                            , sliceEnabled
                                            , pcPic->getSlice(0)->getLambdas()
#if SAO_ENCODE_ALLOW_USE_PREDEBLOCK
                                            , m_pcCfg->getSaoLcuBoundary()
#endif
                                            );
                        m_pcSAO->PCMLFDisableProcess(pcPic);
                        
                        //assign SAO slice header
                        for(Int s=0; s< uiNumSlices; s++)
                        {
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
                            assert(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]);
                            pcPic->getSlice(s)->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
                        }
                    }
                    
                    processingState = ENCODE_SLICE;
                }
                    break;
                    
                default:
                {
                    printf("Not a supported encoding state\n");
                    assert(0);
                    exit(-1);
                }
            }
        } // end iteration over slices
        
        pcPic->compressMotion();
        
        //-- For time output for each slice
        Double dEncTime = (Double)(clock()-iBeforeTime) / CLOCKS_PER_SEC;
        
        std::string digestStr;
        if (m_pcCfg->getDecodedPictureHashSEIEnabled())
        {
            /* calculate MD5sum for entire reconstructed picture */
            SEIDecodedPictureHash sei_recon_picture_digest;
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::MD5;
                UInt numChar=calcMD5(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CRC;
                UInt numChar=calcCRC(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                sei_recon_picture_digest.method = SEIDecodedPictureHash::CHECKSUM;
                UInt numChar=calcChecksum(*pcPic->getPicYuvRec(), sei_recon_picture_digest.m_digest);
                digestStr = digestToString(sei_recon_picture_digest.m_digest, numChar);
            }
            OutputNALUnit nalu(NAL_UNIT_SUFFIX_SEI, pcSlice->getTLayer());
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_recon_picture_digest, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            accessUnit.insert(accessUnit.end(), new NALUnitEBSP(nalu));
        }
        if (m_pcCfg->getTemporalLevel0IndexSEIEnabled())
        {
            SEITemporalLevel0Index sei_temporal_level0_index;
            if (pcSlice->getRapPicFlag())
            {
                m_tl0Idx = 0;
                m_rapIdx = (m_rapIdx + 1) & 0xFF;
            }
            else
            {
                m_tl0Idx = (m_tl0Idx + (pcSlice->getTLayer() ? 0 : 1)) & 0xFF;
            }
            sei_temporal_level0_index.tl0Idx = m_tl0Idx;
            sei_temporal_level0_index.rapIdx = m_rapIdx;
            
            OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI);
            
            /* write the SEI messages */
            m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
            m_seiWriter.writeSEImessage(nalu.m_Bitstream, sei_temporal_level0_index, pcSlice->getSPS());
            writeRBSPTrailingBits(nalu.m_Bitstream);
            
            /* insert the SEI message NALUnit before any Slice NALUnits */
            AccessUnit::iterator it = find_if(accessUnit.begin(), accessUnit.end(), mem_fun(&NALUnit::isSlice));
            accessUnit.insert(it, new NALUnitEBSP(nalu));
        }
        
        xCalculateAddPSNR( pcPic, pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        //           xCalculateAddPSNR( pcPic, pcPic->getPicYuvOrg(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        
        //In case of field coding, compute the interlaced PSNR for both fields
        if (isField && ((!pcPic->isTopField() && isTff) || (pcPic->isTopField() && !isTff)) && (pcPic->getPOC()%m_iGopSize != 1))
        {
            //get complementary top field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()-1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPicFirstField, pcPic, pcPicFirstField->getPicYuvRec(), pcPic->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        else if (isField && pcPic->getPOC()!= 0 && (pcPic->getPOC()%m_iGopSize == 0))
        {
            //get complementary bottom field
            
            TComList<TComPic*>::iterator   iterPic = rcListPic.begin();
            while ((*iterPic)->getPOC() != pcPic->getPOC()+1)
            {
                iterPic ++;
            }
            TComPic* pcPicFirstField = *(iterPic);
            xCalculateInterlacedAddPSNR(pcPic, pcPicFirstField, pcPic->getPicYuvRec(), pcPicFirstField->getPicYuvRec(), accessUnit, dEncTime, snr_conversion, printFrameMSE );
        }
        
        if (!digestStr.empty())
        {
            if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 1)
            {
                printf(" [MD5:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 2)
            {
                printf(" [CRC:%s]", digestStr.c_str());
            }
            else if(m_pcCfg->getDecodedPictureHashSEIEnabled() == 3)
            {
                printf(" [Checksum:%s]", digestStr.c_str());
            }
        }
        
        if ( m_pcCfg->getUseRateCtrl() )
        {
            Double avgQP     = m_pcRateCtrl->getRCPic()->calAverageQP();
            Double avgLambda = m_pcRateCtrl->getRCPic()->calAverageLambda();
            if ( avgLambda < 0.0 )
            {
                avgLambda = lambda;
            }
            
            m_pcRateCtrl->getRCPic()->updateAfterPicture( actualHeadBits, actualTotalBits, avgQP, avgLambda, pcSlice->getSliceType());
            m_pcRateCtrl->getRCPic()->addToPictureLsit( m_pcRateCtrl->getPicList() );
            
            m_pcRateCtrl->getRCSeq()->updateAfterPic( actualTotalBits );
            if ( pcSlice->getSliceType() != I_SLICE )
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( actualTotalBits );
            }
            else    // for intra picture, the estimated bits are used to update the current status in the GOP
            {
                m_pcRateCtrl->getRCGOP()->updateAfterPicture( estimatedBits );
            }
        }
        
        if( ( m_pcCfg->getPictureTimingSEIEnabled() || m_pcCfg->getDecodingUnitInfoSEIEnabled() ) &&
           ( pcSlice->getSPS()->getVuiParametersPresentFlag() ) &&
           ( ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getNalHrdParametersPresentFlag() )
            || ( pcSlice->getSPS()->getVuiParameters()->getHrdParameters()->getVclHrdParametersPresentFlag() ) ) )
        {
            TComVUI *vui = pcSlice->getSPS()->getVuiParameters();
            TComHRD *hrd = vui->getHrdParameters();
            
            if( hrd->getSubPicCpbParamsPresentFlag() )
            {
                Int i;
                UInt64 ui64Tmp;
                UInt uiPrev = 0;
                UInt numDU = ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 );
                UInt *pCRD = &pictureTimingSEI.m_duCpbRemovalDelayMinus1[0];
                UInt maxDiff = ( hrd->getTickDivisorMinus2() + 2 ) - 1;
                
                for( i = 0; i < numDU; i ++ )
                {
                    pictureTimingSEI.m_numNalusInDuMinus1[ i ]       = ( i == 0 ) ? ( accumNalsDU[ i ] - 1 ) : ( accumNalsDU[ i ] - accumNalsDU[ i - 1] - 1 );
                }
                
                if( numDU == 1 )
                {
                    pCRD[ 0 ] = 0; /* don't care */
                }
                else
                {
                    pCRD[ numDU - 1 ] = 0;/* by definition */
                    UInt tmp = 0;
                    UInt accum = 0;
                    
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            tmp ++;
                        }
                    }
                    uiPrev = 0;
                    
                    UInt flag = 0;
                    for( i = ( numDU - 2 ); i >= 0; i -- )
                    {
                        flag = 0;
                        ui64Tmp = ( ( ( accumBitsDU[ numDU - 1 ]  - accumBitsDU[ i ] ) * ( vui->getTimingInfo()->getTimeScale() / vui->getTimingInfo()->getNumUnitsInTick() ) * ( hrd->getTickDivisorMinus2() + 2 ) ) / ( m_pcCfg->getTargetBitrate() ) );
                        
                        if( (UInt)ui64Tmp > maxDiff )
                        {
                            if(uiPrev >= maxDiff - tmp)
                            {
                                ui64Tmp = uiPrev + 1;
                                flag = 1;
                            }
                            else                            ui64Tmp = maxDiff - tmp + 1;
                        }
                        pCRD[ i ] = (UInt)ui64Tmp - uiPrev - 1;
                        if( (Int)pCRD[ i ] < 0 )
                        {
                            pCRD[ i ] = 0;
                        }
                        else if (tmp > 0 && flag == 1)
                        {
                            tmp --;
                        }
                        accum += pCRD[ i ] + 1;
                        uiPrev = accum;
                    }
                }
            }
            
            if( m_pcCfg->getPictureTimingSEIEnabled() )
            {
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    pictureTimingSEI.m_picStruct = (isField && pcSlice->getPic()->isTopField())? 1 : isField? 2 : 0;
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, pictureTimingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_pictureTimingSEIPresentInAU = true;
                }
                
                if ( m_pcCfg->getScalableNestingSEIEnabled() ) // put picture timing SEI into scalable nesting SEI
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                    scalableNestingSEI.m_nestedSEIs.clear();
                    scalableNestingSEI.m_nestedSEIs.push_back(&pictureTimingSEI);
                    m_seiWriter.writeSEImessage(nalu.m_Bitstream, scalableNestingSEI, pcSlice->getSPS());
                    writeRBSPTrailingBits(nalu.m_Bitstream);
                    UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                    UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                    + m_bufferingPeriodSEIPresentInAU + m_pictureTimingSEIPresentInAU + m_nestedBufferingPeriodSEIPresentInAU;    // Insert PT SEI after APS and BP SEI
                    AccessUnit::iterator it;
                    for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                    {
                        it++;
                    }
                    accessUnit.insert(it, new NALUnitEBSP(nalu));
                    m_nestedPictureTimingSEIPresentInAU = true;
                }
            }
            
            if( m_pcCfg->getDecodingUnitInfoSEIEnabled() && hrd->getSubPicCpbParamsPresentFlag() )
            {
                m_pcEntropyCoder->setEntropyCoder(m_pcCavlcCoder, pcSlice);
                for( Int i = 0; i < ( pictureTimingSEI.m_numDecodingUnitsMinus1 + 1 ); i ++ )
                {
                    OutputNALUnit nalu(NAL_UNIT_PREFIX_SEI, pcSlice->getTLayer());
                    
                    SEIDecodingUnitInfo tempSEI;
                    tempSEI.m_decodingUnitIdx = i;
                    tempSEI.m_duSptCpbRemovalDelay = pictureTimingSEI.m_duCpbRemovalDelayMinus1[i] + 1;
                    tempSEI.m_dpbOutputDuDelayPresentFlag = false;
                    tempSEI.m_picSptDpbOutputDuDelay = picSptDpbOutputDuDelay;
                    
                    AccessUnit::iterator it;
                    // Insert the first one in the right location, before the first slice
                    if(i == 0)
                    {
                        // Insert before the first slice.
                        m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                        writeRBSPTrailingBits(nalu.m_Bitstream);
                        
                        UInt seiPositionInAu = xGetFirstSeiLocation(accessUnit);
                        UInt offsetPosition = m_activeParameterSetSEIPresentInAU
                        + m_bufferingPeriodSEIPresentInAU
                        + m_pictureTimingSEIPresentInAU;  // Insert DU info SEI after APS, BP and PT SEI
                        for(j = 0, it = accessUnit.begin(); j < seiPositionInAu + offsetPosition; j++)
                        {
                            it++;
                        }
                        accessUnit.insert(it, new NALUnitEBSP(nalu));
                    }
                    else
                    {
                        Int ctr;
                        // For the second decoding unit onwards we know how many NALUs are present
                        for (ctr = 0, it = accessUnit.begin(); it != accessUnit.end(); it++)
                        {
                            if(ctr == accumNalsDU[ i - 1 ])
                            {
                                // Insert before the first slice.
                                m_seiWriter.writeSEImessage(nalu.m_Bitstream, tempSEI, pcSlice->getSPS());
                                writeRBSPTrailingBits(nalu.m_Bitstream);
                                
                                accessUnit.insert(it, new NALUnitEBSP(nalu));
                                break;
                            }
                            if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
                            {
                                ctr++;
                            }
                        }
                    }
                }
            }
        }
        
        
#endif // end is enable encoding
        
        xResetNonNestedSEIPresentFlags();
        xResetNestedSEIPresentFlags();
        
        
#if IS_ENABLE_ENCODING
        // Hossam: Scene Change: Copy the rec of the pcPic to the out of pcPic
        pcPic->getPicYuvRec()->copyToPic(pcPicYuvRecOut);
#endif
        
        pcPic->setReconMark   ( true );
        m_bFirst = false;
        m_iNumPicCoded++;
        m_totalCoded ++;
        /* logging: insert a newline at end of picture period */
        printf("\n");
        fflush(stdout);
        
        delete[] pcSubstreamsOut;
        
#if EFFICIENT_FIELD_IRAP
        if(IRAPtoReorder)
        {
            if(swapIRAPForward)
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid +1;
                    IRAPtoReorder = false;
                }
                else if(iGOPid == IRAPGOPid +1)
                {
                    iGOPid --;
                }
            }
            else
            {
                if(iGOPid == IRAPGOPid)
                {
                    iGOPid = IRAPGOPid -1;
                }
                else if(iGOPid == IRAPGOPid -1)
                {
                    iGOPid = IRAPGOPid;
                    IRAPtoReorder = false;
                }
            }
        }
#endif
    }
    
    delete pcBitstreamRedirect;
    
    if( accumBitsDU != NULL) delete accumBitsDU;
    if( accumNalsDU != NULL) delete accumNalsDU;
    
    
#if IS_ENABLE_ENCODING
    assert ( (m_iNumPicCoded == iNumPicRcvd) );
#endif
    
}



//// P Frames


Void TEncGOP::printOutSummary(UInt uiNumAllPicCoded, Bool isField, const Bool printMSEBasedSNR, const Bool printSequenceMSE)
{
    
#if IS_ENABLE_ENCODING
    
    assert (uiNumAllPicCoded == m_gcAnalyzeAll.getNumPic());
    
    
    //--CFG_KDY
    const Int rateMultiplier=(isField?2:1);
    m_gcAnalyzeAll.setFrmRate( m_pcCfg->getFrameRate()*rateMultiplier );
    m_gcAnalyzeI.setFrmRate( m_pcCfg->getFrameRate()*rateMultiplier );
    m_gcAnalyzeP.setFrmRate( m_pcCfg->getFrameRate()*rateMultiplier );
    m_gcAnalyzeB.setFrmRate( m_pcCfg->getFrameRate()*rateMultiplier );
    const ChromaFormat chFmt = m_pcCfg->getChromaFormatIdc();
    
    //-- all
    printf( "\n\nSUMMARY --------------------------------------------------------\n" );
    m_gcAnalyzeAll.printOut('a', chFmt, printMSEBasedSNR, printSequenceMSE);
    
    printf( "\n\nI Slices--------------------------------------------------------\n" );
    m_gcAnalyzeI.printOut('i', chFmt, printMSEBasedSNR, printSequenceMSE);
    
    printf( "\n\nP Slices--------------------------------------------------------\n" );
    m_gcAnalyzeP.printOut('p', chFmt, printMSEBasedSNR, printSequenceMSE);
    
    printf( "\n\nB Slices--------------------------------------------------------\n" );
    m_gcAnalyzeB.printOut('b', chFmt, printMSEBasedSNR, printSequenceMSE);
    
#if _SUMMARY_OUT_
    m_gcAnalyzeAll.printSummary(chFmt, printSequenceMSE);
#endif
#if _SUMMARY_PIC_
    m_gcAnalyzeI.printSummary(chFmt, printSequenceMSE,'I');
    m_gcAnalyzeP.printSummary(chFmt, printSequenceMSE,'P');
    m_gcAnalyzeB.printSummary(chFmt, printSequenceMSE,'B');
#endif
    
    if(isField)
    {
        //-- interlaced summary
        m_gcAnalyzeAll_in.setFrmRate( m_pcCfg->getFrameRate());
        m_gcAnalyzeAll_in.setBits(m_gcAnalyzeAll.getBits());
        // NOTE: RExt - prior to the above statement, the interlace analyser does not contain the correct total number of bits.
        
        printf( "\n\nSUMMARY INTERLACED ---------------------------------------------\n" );
        m_gcAnalyzeAll_in.printOut('a', chFmt, printMSEBasedSNR, printSequenceMSE);
        
#if _SUMMARY_OUT_
        m_gcAnalyzeAll_in.printSummary(chFmt, printSequenceMSE);
#endif
    }
    
    printf("\nRVM: %.3lf\n" , xCalculateRVM());
    
#endif// end is enable encoding
    
    
}

Void TEncGOP::preLoopFilterPicAll( TComPic* pcPic, UInt64& ruiDist, UInt64& ruiBits )
{
    TComSlice* pcSlice = pcPic->getSlice(pcPic->getCurrSliceIdx());
    Bool bCalcDist = false;
    m_pcLoopFilter->setCfg(m_pcCfg->getLFCrossTileBoundaryFlag());
    m_pcLoopFilter->loopFilterPic( pcPic );
    
    m_pcEntropyCoder->setEntropyCoder ( m_pcEncTop->getRDGoOnSbacCoder(), pcSlice );
    m_pcEntropyCoder->resetEntropy    ();
    m_pcEntropyCoder->setBitstream    ( m_pcBitCounter );
    
    m_pcEntropyCoder->resetEntropy    ();
    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
    
    if (!bCalcDist)
        ruiDist = xFindDistortionFrame(pcPic->getPicYuvOrg(), pcPic->getPicYuvRec());
}

// ====================================================================================================================
// Protected member functions
// ====================================================================================================================


Void TEncGOP::xInitGOP( Int iPOCLast, Int iNumPicRcvd, TComList<TComPic*>& rcListPic, TComList<TComPicYuv*>& rcListPicYuvRecOut, Bool isField )
{
    assert( iNumPicRcvd > 0 );
    
    //    cout << "Yang: TEncGOP: xInitGOP: I'm initilizing GOP dude" << "\n" << endl;
    //    getchar();
    
    //****************************** Hossam: Changing the GOP size Starts-- Code Tweaking!!*********************************************
    
    // This won't be called except at the start of the GOP, if you change it in the middle then you have to tweak it yourself!
    /*
     cout << "Yang: TEncGOP: xInitGOP: GOP size is Getting CONTROL! XXX :) -- GOP size " << iPOCLast  << "\n" << endl;
     if(iPOCLast == 1)// I am in the third frame-- force a GOP size 1
     {
     m_iGopSize = 1;
     cout << "Yang: TEncGOP: xInitGOP: GOP size is in full CONTROL! XXX :) -- GOP size " << m_iGopSize  << "\n" << endl;
     //          getchar();
     
     }
     else
     */
    //****************************** Hossam: Changing the GOP size Ends -- Code Tweaking!!**********************************************
    
    // Dady: isField is always true
    //  Exception for the first frames
    if ( ( isField && (iPOCLast == 0 || iPOCLast == 1) ) || (!isField  && (iPOCLast == 0))  )
    {
        m_iGopSize    = 1;
        
//        cout << "Yang: TEncGOP: xInitGOP: I'm initilizing GOP dude-Case first frame -- GOP size " << m_iGopSize  << "\n" << endl;
        //          getchar();
        
    }
    else
    {
        m_iGopSize    = m_pcCfg->getGOPSize();
        
//        cout << "Yang: TEncGOP: xInitGOP: I'm initilizing GOP from CFG - Case NOT first frame -- GOP size " << m_iGopSize  << "\n" << endl;
        //          getchar();
        
    }
    assert (m_iGopSize > 0);
    
    return;
}


Void TEncGOP::xGetBuffer( TComList<TComPic*>&      rcListPic,
                         TComList<TComPicYuv*>&    rcListPicYuvRecOut,
                         Int                       iNumPicRcvd,
                         Int                       iTimeOffset,
                         TComPic*&                 rpcPic,
                         TComPicYuv*&              rpcPicYuvRecOut,
                         Int                       pocCurr,
                         Bool                      isField)
{
    Int i;
    //  Rec. output
    TComList<TComPicYuv*>::iterator     iterPicYuvRec = rcListPicYuvRecOut.end();
    
    
    if (isField && pocCurr > 2 && m_iGopSize!=1)
    {
        iTimeOffset--;
    }
    
    for ( i = 0; i < (iNumPicRcvd - iTimeOffset + 1); i++ )
    {
        iterPicYuvRec--;
    }
    
    rpcPicYuvRecOut = *(iterPicYuvRec);
    
//    cout << "Located the rpcPicYuvRecOut " << rpcPicYuvRecOut << ", loop i to " << (iNumPicRcvd-iTimeOffset+1) << ", rvd " << iNumPicRcvd << ", timeOffset " << iTimeOffset << endl;
    

    //  Current pic.
    TComList<TComPic*>::iterator        iterPic       = rcListPic.begin();
    
//    cout << "xGetBuffer CompressGOP Sizes for rcListPic " << rcListPic.size() << endl;
    
    while (iterPic != rcListPic.end())
    {
        
        rpcPic = *(iterPic);
        rpcPic->setCurrSliceIdx(0);
        
//        cout << "rpcPic->getPOC in buffer now: " << rpcPic->getPOC() << endl;
        if (rpcPic->getPOC() == pocCurr)
        {
            break;
        }
        iterPic++;
    }
    
    
    // rpcPic->getPoc is wrong()
//    cout << "xGetBuffer TencGop mismatch in numbers  " << rpcPic->getPOC() << ", " << pocCurr << endl;
    assert (rpcPic != NULL);
    assert (rpcPic->getPOC() == pocCurr);
    
    return;
}


Void TEncGOP::showMeRcListsGOP( TComList<TComPic*>&      rcListPic)
{
    
    cout << "\n\n******RC List****** " << endl;
    
    TComPic* rpcPic;
    // loop through all pictures in the reference picture buffer
    TComList<TComPic*>::iterator iterPic = rcListPic.begin();
    while ( iterPic != rcListPic.end())
    {
        rpcPic = *(iterPic++);
        cout << "Frame " << rpcPic->getPicSym()->getSlice(0)->getPOC() << ", " << rpcPic->getSlice(0)->isReferenced() << endl;
    }

    
    return;
}


Void TEncGOP::xGetBufferMock( TComList<TComPic*>&      rcListPic,
                         TComList<TComPicYuv*>&    rcListPicYuvRecOut,
                         Int                       iNumPicRcvd,
                         Int                       iTimeOffset,
                         TComPic*&                 rpcPic,
                         TComPicYuv*&              rpcPicYuvRecOut,
                         Int                       pocCurr,
                         Bool                      isField)
{
//    Int i;
//    //  Rec. output
//    TComList<TComPicYuv*>::iterator     iterPicYuvRec = rcListPicYuvRecOut.end();
    
    
//    if (isField && pocCurr > 2 && m_iGopSize!=1)
//    {
//        iTimeOffset--;
//    }
//    
//    for ( i = 0; i < (iNumPicRcvd - iTimeOffset + 1); i++ )
//    {
//        iterPicYuvRec--;
//    }
//    
//    rpcPicYuvRecOut = *(iterPicYuvRec);
    
    //    cout << "Located the rpcPicYuvRecOut " << rpcPicYuvRecOut << ", loop i to " << (iNumPicRcvd-iTimeOffset+1) << ", rvd " << iNumPicRcvd << ", timeOffset " << iTimeOffset << endl;
    
    
//    cout << "Before xGetBufferMock show me rcList " << endl;
//    showMeRcListsGOP(rcListPic);
    
    //  Current pic.
    TComList<TComPic*>::iterator        iterPic       = rcListPic.begin();
    
    //    cout << "xGetBuffer CompressGOP Sizes for rcListPic " << rcListPic.size() << endl;
    
    while (iterPic != rcListPic.end())
    {
        
        rpcPic = *(iterPic);
        rpcPic->setCurrSliceIdx(0);
        
//        cout << "rpcPic->getPOC in buffer now: " << rpcPic->getPOC() << endl;
        if (rpcPic->getPOC() == pocCurr)
        {
            break;
        }
        iterPic++;
    }
    
    
    // rpcPic->getPoc is wrong()
//    cout << "xGetBuffer TencGop mismatch in numbers  " << rpcPic->getPOC() << ", " << pocCurr << endl;
    assert (rpcPic != NULL);
    assert (rpcPic->getPOC() == pocCurr);
    
    
//    cout << "After xGetBufferMock show me rcList " << endl;
//    showMeRcListsGOP(rcListPic);

    
    return;
}


// Hossam: xGetBufferActual does the same thing as xGetbuffer, but with popping all the irrelevant items
// greater than poc curr
Void TEncGOP::xGetBufferActual( TComList<TComPic*>&      rcListPic,
                         TComList<TComPicYuv*>&    rcListPicYuvRecOut,
                         Int                       iNumPicRcvd,
                         Int                       iTimeOffset,
                         TComPic*&                 rpcPic,
                         TComPicYuv*&              rpcPicYuvRecOut,
                         Int                       pocCurr,
                         Bool                      isField)
{
    Int i;
    //  Rec. output
    TComList<TComPicYuv*>::iterator     iterPicYuvRec = rcListPicYuvRecOut.end();
    
    
    if (isField && pocCurr > 2 && m_iGopSize!=1)
    {
        iTimeOffset--;
    }
    
    UInt loopI_to = 1; // Hossam: I output one picture by one picture
//    for ( i = 0; i < (iNumPicRcvd - iTimeOffset + 1); i++ )
    for ( i = 0; i < loopI_to; i++ )
    {
        iterPicYuvRec--;
    }
    
    rpcPicYuvRecOut = *(iterPicYuvRec);
    
    //  Current pic.
    TComList<TComPic*>::iterator        iterPic       = rcListPic.begin();
    
//    cout << "xGetBuffer CompressGOP Sizes for rcListPic " << rcListPic.size() << endl;
//     cout << "xGetBuffer CompressGOP XXX need to check the erase step "  << endl;
    
    // pop the future
    while (iterPic != rcListPic.end())
    {
        rpcPic = *(iterPic);

        // Pop the look ahead elements
        if(rpcPic->getPOC() > pocCurr)
        {
            rcListPic.erase(iterPic);
            
            // XXXXXXX XXXXX
            cout << "XXXXXXXXXXXXX EEEEE xGetBufferActual rpcPic->getPOC erase from buffer now: " << rpcPic->getPOC() << endl;
        }
        
        iterPic++;
    }
    // Find the rpcPic
    iterPic       = rcListPic.begin();
    while (iterPic != rcListPic.end())
    {
        rpcPic = *(iterPic);
        rpcPic->setCurrSliceIdx(0);
        
//        cout << "xGetBufferActual rpcPic->getPOC in buffer now: " << rpcPic->getPOC() << endl;
        if (rpcPic->getPOC() == pocCurr)
        {
            break;
        }
        iterPic++;
    }
    
    
    // rpcPic->getPoc is wrong()
//    cout << "xGetBuffer TencGop mismatch in numbers  " << rpcPic->getPOC() << ", " << pocCurr << endl;
    assert (rpcPic != NULL);
    assert (rpcPic->getPOC() == pocCurr);
    
    return;
}



// Hossam: Scene Change
Void TEncGOP::xGetBufferNew( TComList<TComPic*>& rcListPic, Int iNumPicRcvd, Int iTimeOffset, TComPic*& rpcPic, Int pocCurr, Bool isField)
{
    
    //  Current pic.
    TComList<TComPic*>::iterator        iterPic       = rcListPic.begin();
    while (iterPic != rcListPic.end())
    {
        rpcPic = *(iterPic);
        rpcPic->setCurrSliceIdx(0);
        if (rpcPic->getPOC() == pocCurr)
        {
            break;
        }
        iterPic++;
    }
    
    assert (rpcPic != NULL);
    assert (rpcPic->getPOC() == pocCurr);
    
    return;
}



UInt64 TEncGOP::xFindDistortionFrame (TComPicYuv* pcPic0, TComPicYuv* pcPic1)
{
    UInt64  uiTotalDiff = 0;
    
    for(Int chan=0; chan<pcPic0 ->getNumberValidComponents(); chan++)
    {
        const ComponentID ch=ComponentID(chan);
        Pel*  pSrc0   = pcPic0 ->getAddr(ch);
        Pel*  pSrc1   = pcPic1 ->getAddr(ch);
        UInt  uiShift     = 2 * DISTORTION_PRECISION_ADJUSTMENT(g_bitDepth[toChannelType(ch)]-8);
        
        const Int   iStride = pcPic0->getStride(ch);
        const Int   iWidth  = pcPic0->getWidth(ch);
        const Int   iHeight = pcPic0->getHeight(ch);
        
        for(Int y = 0; y < iHeight; y++ )
        {
            for(Int x = 0; x < iWidth; x++ )
            {
                Intermediate_Int iTemp = pSrc0[x] - pSrc1[x];
                uiTotalDiff += UInt64((iTemp*iTemp) >> uiShift);
            }
            pSrc0 += iStride;
            pSrc1 += iStride;
        }
    }
    
    return uiTotalDiff;
}

#if VERBOSE_RATE
static const Char* nalUnitTypeToString(NalUnitType type)
{
    switch (type)
    {
        case NAL_UNIT_CODED_SLICE_TRAIL_R:    return "TRAIL_R";
        case NAL_UNIT_CODED_SLICE_TRAIL_N:    return "TRAIL_N";
        case NAL_UNIT_CODED_SLICE_TSA_R:      return "TSA_R";
        case NAL_UNIT_CODED_SLICE_TSA_N:      return "TSA_N";
        case NAL_UNIT_CODED_SLICE_STSA_R:     return "STSA_R";
        case NAL_UNIT_CODED_SLICE_STSA_N:     return "STSA_N";
        case NAL_UNIT_CODED_SLICE_BLA_W_LP:   return "BLA_W_LP";
        case NAL_UNIT_CODED_SLICE_BLA_W_RADL: return "BLA_W_RADL";
        case NAL_UNIT_CODED_SLICE_BLA_N_LP:   return "BLA_N_LP";
        case NAL_UNIT_CODED_SLICE_IDR_W_RADL: return "IDR_W_RADL";
        case NAL_UNIT_CODED_SLICE_IDR_N_LP:   return "IDR_N_LP";
        case NAL_UNIT_CODED_SLICE_CRA:        return "CRA";
        case NAL_UNIT_CODED_SLICE_RADL_R:     return "RADL_R";
        case NAL_UNIT_CODED_SLICE_RADL_N:     return "RADL_N";
        case NAL_UNIT_CODED_SLICE_RASL_R:     return "RASL_R";
        case NAL_UNIT_CODED_SLICE_RASL_N:     return "RASL_N";
        case NAL_UNIT_VPS:                    return "VPS";
        case NAL_UNIT_SPS:                    return "SPS";
        case NAL_UNIT_PPS:                    return "PPS";
        case NAL_UNIT_ACCESS_UNIT_DELIMITER:  return "AUD";
        case NAL_UNIT_EOS:                    return "EOS";
        case NAL_UNIT_EOB:                    return "EOB";
        case NAL_UNIT_FILLER_DATA:            return "FILLER";
        case NAL_UNIT_PREFIX_SEI:             return "SEI";
        case NAL_UNIT_SUFFIX_SEI:             return "SEI";
        default:                              return "UNK";
    }
}
#endif

Void TEncGOP::xCalculateAddPSNR( TComPic* pcPic, TComPicYuv* pcPicD, const AccessUnit& accessUnit, Double dEncTime, const InputColourSpaceConversion conversion, const Bool printFrameMSE )
{
    Double  dPSNR[MAX_NUM_COMPONENT];
    
    for(Int i=0; i<MAX_NUM_COMPONENT; i++)
    {
        dPSNR[i]=0.0;
    }
    
    TComPicYuv cscd;
    if (conversion!=IPCOLOURSPACE_UNCHANGED)
    {
        cscd.create(pcPicD->getWidth(COMPONENT_Y), pcPicD->getHeight(COMPONENT_Y), pcPicD->getChromaFormat(), g_uiMaxCUWidth, g_uiMaxCUHeight, g_uiMaxCUDepth);
        TVideoIOYuv::ColourSpaceConvert(*pcPicD, cscd, conversion, g_bitDepth, false);
    }
    TComPicYuv &picd=(conversion==IPCOLOURSPACE_UNCHANGED)?*pcPicD : cscd;
    
    //===== calculate PSNR =====
    Double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
    for(Int chan=0; chan<pcPicD->getNumberValidComponents(); chan++)
    {
        const ComponentID ch=ComponentID(chan);
        const Pel*  pOrg    = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
        Pel*  pRec    = picd.getAddr(ch);
        const Int   iStride = pcPicD->getStride(ch);
        
        const Int   iWidth  = pcPicD->getWidth (ch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(ch));
        const Int   iHeight = pcPicD->getHeight(ch) - (m_pcEncTop->getPad(1) >> pcPic->getComponentScaleY(ch));
        
        Int   iSize   = iWidth*iHeight;
        
        UInt64 uiSSDtemp=0;
        for(Int y = 0; y < iHeight; y++ )
        {
            for(Int x = 0; x < iWidth; x++ )
            {
                Intermediate_Int iDiff = (Intermediate_Int)( pOrg[x] - pRec[x] );
                uiSSDtemp   += iDiff * iDiff;
            }
            pOrg += iStride;
            pRec += iStride;
        }
        const Int maxval = 255 << (g_bitDepth[toChannelType(ch)] - 8);
        const Double fRefValue = (Double) maxval * maxval * iSize;
        dPSNR[ch]         = ( uiSSDtemp ? 10.0 * log10( fRefValue / (Double)uiSSDtemp ) : 999.99 );
        MSEyuvframe[ch]   = (Double)uiSSDtemp/(iSize);
    }
    
    
    /* calculate the size of the access unit, excluding:
     *  - any AnnexB contributions (start_code_prefix, zero_byte, etc.,)
     *  - SEI NAL units
     */
    UInt numRBSPBytes = 0;
    for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
    {
        UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
#if VERBOSE_RATE
        printf("*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
#endif
        if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
        {
            numRBSPBytes += numRBSPBytes_nal;
        }
        
//        cout << "numRBSP Bytes AddPSNR " << numRBSPBytes << endl;
    }
    
    
    UInt uibits = numRBSPBytes * 8;
    m_vRVM_RP.push_back( uibits );
    
    
//    cout << "GGGGGGGGGG bits, PSNR " << uibits << ", " << dPSNR[COMPONENT_Y] << endl;
    // Hossam: GOP_STR_TYPE
    //    m_gcAnalyzeAll.setGOPStrTypeWithFileName(m_pcCfg -> getGOPStrType(), m_pcCfg -> getInputFileName());
    
//    cout << "Hello1 " << endl;
    //===== add PSNR =====
    m_gcAnalyzeAll.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    TComSlice*  pcSlice = pcPic->getSlice(0);
    if (pcSlice->isIntra())
    {
        m_gcAnalyzeI.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterP())
    {
        m_gcAnalyzeP.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterB())
    {
        m_gcAnalyzeB.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
//    cout << "Hello3 " << endl;
    Char c = (pcSlice->isIntra() ? 'I' : pcSlice->isInterP() ? 'P' : 'B');
    if (!pcSlice->isReferenced()) c += 32;
    
#if ADAPTIVE_QP_SELECTION
    printf("POC %4d TId: %1d ( %c-SLICE, nQP %d QP %d ) %10d bits",
           pcSlice->getPOC(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQpBase(),
           pcSlice->getSliceQp(),
           uibits );
#else
    printf("POC %4d TId: %1d ( %c-SLICE, QP %d ) %10d bits",
           pcSlice->getPOC()-pcSlice->getLastIDR(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQp(),
           uibits );
#endif
    
    
//    cout << "Hello4 " << endl;
    /////////////////////////////////////////////////
    // Hossam: Here is reported the reference frames
    printf(" [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );

    //////////////////////////////// ANALYSIS ////////////////////////////////////////// ANALYSIS
   // cout << "\nOUTPUTTING THE MSE for per frame" << endl;
#if GEN_MSE_FILES
    string fileName2 = "";
    std::ostringstream oss2;
    oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_MSE" << g_qpInit  << ".txt";
    fileName2 = oss2.str();
    Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
    FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
    fprintf(mse_pFile2, "%6.4lf\n", MSEyuvframe[COMPONENT_Y]);
    fclose(mse_pFile2);
#endif
    // Disable this part for now
//    UInt pred_poc = 16; // key frame
//    UInt start_poc = 14;
//    UInt end_poc = 16;
//    UInt pred_poc = -1; // key frame
//    UInt start_poc = -1;
//    UInt end_poc = -1;
////    if (pcSlice->getPOC() ==  (start_poc+end_poc)/2 || pcSlice->getPOC() == pred_poc) {
//    if (pcSlice->getPOC() ==  1 || pcSlice->getPOC() == 2) {
//    
//        cout << "\nOUTPUTTING THE MSE for reference and predicted frames " << endl;
//        
//        string fileName = "";
//        std::ostringstream oss;
////        if (pcSlice->getPOC() == (start_poc+end_poc)/2) {
//        if (pcSlice->getPOC() == 1) {
//            oss << "Gen//Seq-TXT//" << g_input_FileName << "_refMSE"  << ".txt";
//        }
////        else if(pcSlice->getPOC() == pred_poc)
//        else if(pcSlice->getPOC() == 2)
//        {
//            oss << "Gen//Seq-TXT//" << g_input_FileName << "_predMSE"  << ".txt";
//        }
//        
//        fileName = oss.str();
//        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//
//        FILE* mse_pFile = fopen (pYUVFileName, "at");
//        if(pcSlice->getPOC() == 2) {
//            fprintf(mse_pFile, "%6.4lf \t %10d \n", MSEyuvframe[COMPONENT_Y], uibits);
//        }
//        else
//        {
//            fprintf(mse_pFile, "%6.4lf \n", MSEyuvframe[COMPONENT_Y]);
//        }
//        fclose(mse_pFile);
//    }
    
    ////////////////////////////Hossam///////////////////////
    ////////////////////////////////////////////////////////
    
    if (printFrameMSE)
    {
        printf(" [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
    }
    printf(" [ET %5.0f ]", dEncTime );
    
    for (Int iRefList = 0; iRefList < 2; iRefList++)
    {
        printf(" [L%d ", iRefList);
        for (Int iRefIndex = 0; iRefIndex < pcSlice->getNumRefIdx(RefPicList(iRefList)); iRefIndex++)
        {
            printf ("%d ", pcSlice->getRefPOC(RefPicList(iRefList), iRefIndex)-pcSlice->getLastIDR());
        }
        printf("]");
    }
    
    cscd.destroy();
    
}
    
    
    
Scalar TEncGOP::getMSSIM(const Mat& i1, const Mat& i2)
{
    const double C1 = 6.5025, C2 = 58.5225;
    /***************************** INITS **********************************/
    int d     = CV_32F;
    
    Mat I1, I2;
    i1.convertTo(I1, d);           // cannot calculate on one byte large values
    i2.convertTo(I2, d);
    
    Mat I2_2   = I2.mul(I2);        // I2^2
    Mat I1_2   = I1.mul(I1);        // I1^2
    Mat I1_I2  = I1.mul(I2);        // I1 * I2
    
    /*************************** END INITS **********************************/
    
    Mat mu1, mu2;   // PRELIMINARY COMPUTING
    GaussianBlur(I1, mu1, Size(11, 11), 1.5);
    GaussianBlur(I2, mu2, Size(11, 11), 1.5);
    
    Mat mu1_2   =   mu1.mul(mu1);
    Mat mu2_2   =   mu2.mul(mu2);
    Mat mu1_mu2 =   mu1.mul(mu2);
    
    Mat sigma1_2, sigma2_2, sigma12;
    
    GaussianBlur(I1_2, sigma1_2, Size(11, 11), 1.5);
    sigma1_2 -= mu1_2;
    
    GaussianBlur(I2_2, sigma2_2, Size(11, 11), 1.5);
    sigma2_2 -= mu2_2;
    
    GaussianBlur(I1_I2, sigma12, Size(11, 11), 1.5);
    sigma12 -= mu1_mu2;
    
    ///////////////////////////////// FORMULA ////////////////////////////////
    Mat t1, t2, t3;
    
    t1 = 2 * mu1_mu2 + C1;
    t2 = 2 * sigma12 + C2;
    t3 = t1.mul(t2);              // t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2))
    
    t1 = mu1_2 + mu2_2 + C1;
    t2 = sigma1_2 + sigma2_2 + C2;
    t1 = t1.mul(t2);               // t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2))
    
    Mat ssim_map;
    divide(t3, t1, ssim_map);      // ssim_map =  t3./t1;
    
    Scalar mssim = mean( ssim_map ); // mssim = average of ssim map
    return mssim;
}

double TEncGOP::getPSNR(const Mat& i1, const Mat& i2, int iSize)
{
    int d     = CV_32F;
    Mat I1, I2;
    i1.convertTo(I1, d);           // cannot calculate on one byte large values
    i2.convertTo(I2, d);
    
    
    Mat s1;
    absdiff(I1, I2, s1);       // |I1 - I2|
    s1.convertTo(s1, CV_32F);  // cannot make a square on 8 bits
    s1 = s1.mul(s1);           // |I1 - I2|^2
    
    Scalar s = sum(s1);         // sum elements per channel
    double mse = (s[0]); // sum channels
    
    if( mse <= 1e-10) // for small values return zero
    {
        return 999.99;
    }
    else
    {
        double psnr = 10.0*log10(double(255*255*double(iSize))/mse);
        return psnr;
    }
}

    

// Use this one for mu and epsilon methods
Void TEncGOP::xCalculateAddPSNRInter( TComPic* pcPic, TComPicYuv* pcPicD, const AccessUnit& accessUnit, Double dEncTime, const InputColourSpaceConversion conversion, const Bool printFrameMSE )
{
    Double  dPSNR[MAX_NUM_COMPONENT];
    
    for(Int i=0; i<MAX_NUM_COMPONENT; i++)
    {
        dPSNR[i]=0.0;
    }
    
    TComPicYuv cscd;
    if (conversion!=IPCOLOURSPACE_UNCHANGED)
    {
        cscd.create(pcPicD->getWidth(COMPONENT_Y), pcPicD->getHeight(COMPONENT_Y), pcPicD->getChromaFormat(), g_uiMaxCUWidth, g_uiMaxCUHeight, g_uiMaxCUDepth);
        TVideoIOYuv::ColourSpaceConvert(*pcPicD, cscd, conversion, g_bitDepth, false);
    }
    TComPicYuv &picd=(conversion==IPCOLOURSPACE_UNCHANGED)?*pcPicD : cscd;
    
    //===== calculate PSNR =====
    Double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
     //===== calculate MSSIM =====
    Double MSSIMyuvframe[MAX_NUM_COMPONENT] = {1, 0, 0};
    Double MPSNRyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
    for(Int chan=0; chan<pcPicD->getNumberValidComponents(); chan++)
    {
        const ComponentID ch=ComponentID(chan);
        const Pel*  pOrg    = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
        Pel*  pRec    = picd.getAddr(ch);
        const Int   iStride = pcPicD->getStride(ch);
        
        const Int   iWidth  = pcPicD->getWidth (ch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(ch));
        const Int   iHeight = pcPicD->getHeight(ch) - (m_pcEncTop->getPad(1) >> pcPic->getComponentScaleY(ch));
        
        Int   iSize   = iWidth*iHeight;
        
        // Create two Mats
        short * pOrgHelp = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
        cv::Mat org(iHeight, iWidth, CV_16UC1, &pOrgHelp[0]);
        short * pRecHelp = picd.getAddr(ch);
        cv::Mat reconstructed(iHeight, iWidth, CV_16UC1, &pRecHelp[0]);
        
        
        // calculate MSSIM
        Scalar final_mssim = getMSSIM(org, reconstructed);
        MSSIMyuvframe[ch] = final_mssim[0];
        cout << ch << "***** MSSIM " << MSSIMyuvframe[ch] << endl;
        cout << "Accumulating bits for slice: " << m_pcSliceEncoder->getTotalPicBits() << endl;
        
        Scalar final_psnr = getPSNR(org, reconstructed, iSize);
        cout << ch << "****** psnr: " << final_psnr[0] << endl;
        
        
        UInt64 uiSSDtemp=0;
        for(Int y = 0; y < iHeight; y++ )
        {
            for(Int x = 0; x < iWidth; x++ )
            {
                Intermediate_Int iDiff = (Intermediate_Int)( pOrg[x] - pRec[x] );
                uiSSDtemp   += iDiff * iDiff;
            }
            pOrg += iStride;
            pRec += iStride;
        }
        const Int maxval = 255 << (g_bitDepth[toChannelType(ch)] - 8);
//        const Double fRefValue = (Double) maxval * maxval * iSize;
//         se7s modification
        ComponentID shsch = COMPONENT_Y;
        int shsWidth = pcPicD->getWidth (shsch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(shsch));
        int shsHeight = pcPicD->getWidth (shsch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(shsch));
        int shsSize = shsWidth*shsHeight;
        const Double fRefValue = (Double) maxval * maxval * shsSize;
        dPSNR[ch]         = ( uiSSDtemp ? 10.0 * log10( fRefValue / (Double)uiSSDtemp ) : 999.99 );
        MSEyuvframe[ch]   = (Double)uiSSDtemp/(iSize);
        
        
//        Scalar final_psnr = getPSNR(org, reconstructed, iSize);
//        MPSNRyuvframe[ch] = final_psnr[0];
//        cout << ch << "***** PSNR " << MPSNRyuvframe[ch] << endl;
    }
    
    
    /* calculate the size of the access unit, excluding:
     *  - any AnnexB contributions (start_code_prefix, zero_byte, etc.,)
     *  - SEI NAL units
     */
    UInt numRBSPBytes = 0;
    for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
    {
        UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
#if VERBOSE_RATE
        printf("*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
#endif
        if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
        {
            numRBSPBytes += numRBSPBytes_nal;
        }
        
        //        cout << "numRBSP Bytes AddPSNR " << numRBSPBytes << endl;
    }
    
    
    UInt uibits = numRBSPBytes * 8;
    m_vRVM_RP.push_back( uibits );
    
    cout << "\n\n" << pcPic->getPOC() << ") UUUUUUUUUU Bits and PSNRY and MSEY " << uibits << ", " << dPSNR[COMPONENT_Y] << ", " <<MSEyuvframe[COMPONENT_Y] << endl;
    
    // Open a file and write the total time
    string fileNameTime = "";
    std::ostringstream ossTime;
    
    ossTime << "/Volumes/MULTICOM105/103_HA/MULTICOM103/set_yuv/Gen//Seq-Stats//" << g_input_FileName << "_" << g_qpInit << ".txt";
    fileNameTime = ossTime.str();
    Char* pYUVFileNameTime = fileNameTime.empty()? NULL: strdup(fileNameTime.c_str());
//    FILE*  my_pFileTime = fopen (pYUVFileNameTime, "at");
    FILE*  my_pFileTime = fopen (pYUVFileNameTime, "w");
    
    string text = "";
    std::ostringstream ossText;
    
    
    double PSNR = (6.0*dPSNR[0] + dPSNR[1] + dPSNR[2])/8.0;
    double MSSIM = (6.0*MSSIMyuvframe[0] + MSSIMyuvframe[1] + MSSIMyuvframe[2])/8.0;
    double bpp   = 1.0*m_pcSliceEncoder->getTotalPicBits()/(g_FrameWidth*g_FrameHeight);
    
    if (pcPicD->getNumberValidComponents() == 1)
    {
        PSNR = dPSNR[0];
        MSSIM = MSSIMyuvframe[0];
    }
//    ossText << g_input_FileName << "_" << g_qpInit << "\t " << dResult << "\n";
    ossText << bpp << "\t" << MSSIM << "\t" << PSNR << "\n";
    text = ossText.str();
    fprintf(my_pFileTime, "%s", text.c_str());
    fclose(my_pFileTime);
    
    //    cout << "GGGGGGGGGG bits, PSNR " << uibits << ", " << dPSNR[COMPONENT_Y] << endl;
    // Hossam: GOP_STR_TYPE
    //    m_gcAnalyzeAll.setGOPStrTypeWithFileName(m_pcCfg -> getGOPStrType(), m_pcCfg -> getInputFileName());
    
    //    cout << "Hello1 " << endl;
    //===== add PSNR =====
    m_gcAnalyzeAll.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    TComSlice*  pcSlice = pcPic->getSlice(0);
    if (pcSlice->isIntra())
    {
        m_gcAnalyzeI.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterP())
    {
        m_gcAnalyzeP.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterB())
    {
        m_gcAnalyzeB.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    //    cout << "Hello3 " << endl;
    Char c = (pcSlice->isIntra() ? 'I' : pcSlice->isInterP() ? 'P' : 'B');
    if (!pcSlice->isReferenced()) c += 32;
    
    
#if ADAPTIVE_QP_SELECTION
    printf("POC %4d TId: %1d ( %c-SLICE, nQP %d QP %d ) %10d bits",
           pcSlice->getPOC(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQpBase(),
           pcSlice->getSliceQp(),
           uibits );
#else
    printf("POC %4d TId: %1d ( %c-SLICE, QP %d ) %10d bits",
           pcSlice->getPOC()-pcSlice->getLastIDR(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQp(),
           uibits );
#endif
    
    
    //    cout << "Hello4 " << endl;
    /////////////////////////////////////////////////
    // Hossam: Here is reported the reference frames
    printf(" [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
    
    //////////////////////////////// ANALYSIS ////////////////////////////////////////// ANALYSIS
    // cout << "\nOUTPUTTING THE MSE for per frame" << endl;
#if GEN_MSE_FILES
    string fileName2 = "";
    std::ostringstream oss2;
    oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_MSE" << g_qpInit  << ".txt";
    fileName2 = oss2.str();
    Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
    FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
    fprintf(mse_pFile2, "%6.4lf\n", MSEyuvframe[COMPONENT_Y]);
    fclose(mse_pFile2);
#endif
    // Disable this part for now
    //    UInt pred_poc = 16; // key frame
    //    UInt start_poc = 14;
    //    UInt end_poc = 16;
//    UInt pred_poc = -1; // key frame
//    UInt start_poc = -1;
//    UInt end_poc = -1;
//    if (pcSlice->getPOC() ==  (start_poc+end_poc)/2 || pcSlice->getPOC() == pred_poc) {
//        
//        cout << "\nOUTPUTTING THE MSE for reference and predicted frames " << endl;
//        
//        string fileName = "";
//        std::ostringstream oss;
//        if (pcSlice->getPOC() == (start_poc+end_poc)/2) {
//            oss << "Gen//Seq-TXT//" << g_input_FileName << "_refMSE"  << ".txt";
//        }
//        else if(pcSlice->getPOC() == pred_poc)
//        {
//            oss << "Gen//Seq-TXT//" << g_input_FileName << "_predMSE"  << ".txt";
//        }
//        
//        fileName = oss.str();
//        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//        
//        FILE* mse_pFile = fopen (pYUVFileName, "at");
//        fprintf(mse_pFile, "%6.4lf\n", MSEyuvframe[COMPONENT_Y]);
//        fclose(mse_pFile);
//    }
    
    ////////////////////////////Hossam///////////////////////
    ////////////////////////////////////////////////////////
    
    if (printFrameMSE)
    {
        printf(" [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
    }
    printf(" [ET %5.0f ]", dEncTime );
    
//    cout << "---Before done calculate PSNR " << endl;
    for (Int iRefList = 0; iRefList < 2; iRefList++)
    {
        printf(" [L%d ", iRefList);
        for (Int iRefIndex = 0; iRefIndex < pcSlice->getNumRefIdx(RefPicList(iRefList)); iRefIndex++)
        {
            printf ("%d ", pcSlice->getRefPOC(RefPicList(iRefList), iRefIndex)-pcSlice->getLastIDR());
        }
        printf("]");
    }
    
    
    // Hossam look ahead: insert the final rate and distortion
    
//    cout << "Before done calculate PSNR " << endl;
    rate_in_sliding_window.push_back(uibits);
    distortion_in_sliding_window.push_back(MSEyuvframe[COMPONENT_Y]);
    encoding_actual_progress++;
    progress_in_sliding_window = encoding_actual_progress;
    ////
    
//    cout << "After done calculate PSNR " << endl;
    
    cscd.destroy();
    
}


Void TEncGOP::xCalculateAddPSNRActual( TComPic* pcPic, TComPicYuv* pcPicD, const AccessUnit& accessUnit, Double dEncTime, const InputColourSpaceConversion conversion, const Bool printFrameMSE )
{
    Double  dPSNR[MAX_NUM_COMPONENT];
    
    for(Int i=0; i<MAX_NUM_COMPONENT; i++)
    {
        dPSNR[i]=0.0;
    }
    
    TComPicYuv cscd;
    if (conversion!=IPCOLOURSPACE_UNCHANGED)
    {
        cscd.create(pcPicD->getWidth(COMPONENT_Y), pcPicD->getHeight(COMPONENT_Y), pcPicD->getChromaFormat(), g_uiMaxCUWidth, g_uiMaxCUHeight, g_uiMaxCUDepth);
        TVideoIOYuv::ColourSpaceConvert(*pcPicD, cscd, conversion, g_bitDepth, false);
    }
    TComPicYuv &picd=(conversion==IPCOLOURSPACE_UNCHANGED)?*pcPicD : cscd;
    
    //===== calculate PSNR =====
    Double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
    for(Int chan=0; chan<pcPicD->getNumberValidComponents(); chan++)
    {
        const ComponentID ch=ComponentID(chan);
        const Pel*  pOrg    = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
        Pel*  pRec    = picd.getAddr(ch);
        const Int   iStride = pcPicD->getStride(ch);
        
        const Int   iWidth  = pcPicD->getWidth (ch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(ch));
        const Int   iHeight = pcPicD->getHeight(ch) - (m_pcEncTop->getPad(1) >> pcPic->getComponentScaleY(ch));
        
        Int   iSize   = iWidth*iHeight;
        
        UInt64 uiSSDtemp=0;
        for(Int y = 0; y < iHeight; y++ )
        {
            for(Int x = 0; x < iWidth; x++ )
            {
                Intermediate_Int iDiff = (Intermediate_Int)( pOrg[x] - pRec[x] );
                uiSSDtemp   += iDiff * iDiff;
            }
            pOrg += iStride;
            pRec += iStride;
        }
        const Int maxval = 255 << (g_bitDepth[toChannelType(ch)] - 8);
        const Double fRefValue = (Double) maxval * maxval * iSize;
        dPSNR[ch]         = ( uiSSDtemp ? 10.0 * log10( fRefValue / (Double)uiSSDtemp ) : 999.99 );
        MSEyuvframe[ch]   = (Double)uiSSDtemp/(iSize);
    }
    
    
    /* calculate the size of the access unit, excluding:
     *  - any AnnexB contributions (start_code_prefix, zero_byte, etc.,)
     *  - SEI NAL units
     */
    UInt numRBSPBytes = 0;
    for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
    {
        UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
#if VERBOSE_RATE
        printf("*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
#endif
        if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
        {
            numRBSPBytes += numRBSPBytes_nal;
        }
        
        //        cout << "numRBSP Bytes AddPSNR " << numRBSPBytes << endl;
    }
    
    
    UInt uibits = numRBSPBytes * 8;
    m_vRVM_RP.push_back( uibits );
    
    
    //    cout << "GGGGGGGGGG bits, PSNR " << uibits << ", " << dPSNR[COMPONENT_Y] << endl;
    // Hossam: GOP_STR_TYPE
    //    m_gcAnalyzeAll.setGOPStrTypeWithFileName(m_pcCfg -> getGOPStrType(), m_pcCfg -> getInputFileName());
    
    //    cout << "Hello1 " << endl;
    //===== add PSNR =====
    m_gcAnalyzeAll.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    TComSlice*  pcSlice = pcPic->getSlice(0);
    if (pcSlice->isIntra())
    {
        m_gcAnalyzeI.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterP())
    {
        m_gcAnalyzeP.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    if (pcSlice->isInterB())
    {
        m_gcAnalyzeB.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    }
    //    cout << "Hello3 " << endl;
    Char c = (pcSlice->isIntra() ? 'I' : pcSlice->isInterP() ? 'P' : 'B');
    if (!pcSlice->isReferenced()) c += 32;
    
#if ADAPTIVE_QP_SELECTION
    printf("POC %4d TId: %1d ( %c-SLICE, nQP %d QP %d ) %10d bits",
           pcSlice->getPOC(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQpBase(),
           pcSlice->getSliceQp(),
           uibits );
#else
    printf("POC %4d TId: %1d ( %c-SLICE, QP %d ) %10d bits",
           pcSlice->getPOC()-pcSlice->getLastIDR(),
           pcSlice->getTLayer(),
           c,
           pcSlice->getSliceQp(),
           uibits );
#endif
    
    
    //    cout << "Hello4 " << endl;
    /////////////////////////////////////////////////
    // Hossam: Here is reported the reference frames
    printf(" [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
    
    //////////////////////////////// ANALYSIS ////////////////////////////////////////// ANALYSIS
    // cout << "\nOUTPUTTING THE MSE for per frame" << endl;
#if GEN_MSE_FILES
    string fileName2 = "";
    std::ostringstream oss2;
    oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_MSE" << g_qpInit  << ".txt";
    fileName2 = oss2.str();
    Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
    FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
    fprintf(mse_pFile2, "%6.4lf\n", MSEyuvframe[COMPONENT_Y]);
    fclose(mse_pFile2);
#endif
    // Disable this part for now
    //    UInt pred_poc = 16; // key frame
    //    UInt start_poc = 14;
    //    UInt end_poc = 16;
    UInt pred_poc = -1; // key frame
    UInt start_poc = -1;
    UInt end_poc = -1;
    if (pcSlice->getPOC() ==  (start_poc+end_poc)/2 || pcSlice->getPOC() == pred_poc) {
        
        cout << "\nOUTPUTTING THE MSE for reference and predicted frames " << endl;
        
        string fileName = "";
        std::ostringstream oss;
        if (pcSlice->getPOC() == (start_poc+end_poc)/2) {
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_refMSE"  << ".txt";
        }
        else if(pcSlice->getPOC() == pred_poc)
        {
            oss << "Gen//Seq-TXT//" << g_input_FileName << "_predMSE"  << ".txt";
        }
        
        fileName = oss.str();
        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        
        FILE* mse_pFile = fopen (pYUVFileName, "at");
        fprintf(mse_pFile, "%6.4lf\n", MSEyuvframe[COMPONENT_Y]);
        fclose(mse_pFile);
    }
    
    ////////////////////////////Hossam///////////////////////
    ////////////////////////////////////////////////////////
    
    if (printFrameMSE)
    {
        printf(" [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
    }
    printf(" [ET %5.0f ]", dEncTime );
    
    for (Int iRefList = 0; iRefList < 2; iRefList++)
    {
        printf(" [L%d ", iRefList);
        for (Int iRefIndex = 0; iRefIndex < pcSlice->getNumRefIdx(RefPicList(iRefList)); iRefIndex++)
        {
            printf ("%d ", pcSlice->getRefPOC(RefPicList(iRefList), iRefIndex)-pcSlice->getLastIDR());
        }
        printf("]");
    }
    
    // Hossam look ahead: insert the final rate and distortion
    rate_in_sliding_window[encoding_actual_progress] = uibits;
    distortion_in_sliding_window [encoding_actual_progress] = MSEyuvframe[COMPONENT_Y];
    encoding_actual_progress++;
    progress_in_sliding_window = encoding_actual_progress;
    ////
    
    
    cscd.destroy();
    
}

// Calculate 4 epsilons
Void TEncGOP::calculate4Epsilons(TComPic *pcPic)
{
    Int curr_poc = pcPic->getPOC();

//    displayDAndSigmaSlidingWindowList(progress_in_sliding_window);
    // visit the past
    //    UInt start_loop_from = progress_in_sliding_window - sliding_window_length;
    // Calculate mu(i, j)
    
//    cout << "\n calculate4Epsilons start " << endl;
    
#if GEN_MU_FILES || IS_DEBUG_MU_TURN_MU
    Double mult = 1;
#endif
    
    
    
    UInt last_frame_encoded = curr_poc;
    UInt start_for_i = m_pcEncTop->getSceneChangeCoder()->getLastSC()==-1? 1:m_pcEncTop->getSceneChangeCoder()->getLastSC()+1;
    

    
//    cout << "\n calculate4Epsilons start " << start_for_i << endl;
    
    
    ////////////// Checker loop
        // high bitrates and at frame POC 20, where you calculated mu(9) -> mu(21)
    if((g_qpInit == 22 || g_qpInit == 27) && last_frame_encoded >= start_for_i + 20)
//    if(last_frame_encoded >= start_for_i + 20)
    {
        
        std::vector<Double> mu_ijChecker;
        
        // Calculate the mu's
        for(UInt i = start_for_i; i <= last_frame_encoded; i++)
        {
            // mu_pred_ref = Dpred / (Dref + sigma^2)
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
            mu_ijChecker.push_back(curr_mu_i_j);
            
#if IS_DEBUG_MU_TURN_MU
            // wanna see the mu's
            cout << "\nOUTPUTTING THE mu orig i, mu_ij " << mu_ijChecker.size()-1 << ", " << mu_ijChecker[mu_ijChecker.size()-1] << endl;
            string fileName2 = "";
            std::ostringstream oss2;
            oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
            fileName2 = oss2.str();
            Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
            FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
            mult = mult*curr_mu_i_j;
            fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
            fclose(mse_pFile2);
#endif
            
        }
        
        // Declare the distance vector
        Int nIter = 3;
        std::vector<Double> distance_percentile(4);
        std::vector<Double> mean_distance_percentile;
        Int to_i_iters = 9+4*nIter;
        for(Int i = 9; i < to_i_iters; i++)
        {
            if(i % getGOPSize() == 0)
            {
                Double sum = 0;
                for (Int j = i; j >= i-3; j--)
                {
                    /// BUG FIX MEXXXX
                    distance_percentile[i] = 100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1];
                    sum += distance_percentile[i];
//                    distance_percentile.push_back(100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1]);
//                    sum += distance_percentile.back();
                    
                }
                
                // mean locally for every four ((((XXXX this should be THREE and not size four!)
                Double mean = sum / distance_percentile.size();
                mean_distance_percentile.push_back(mean);
            }
        }
        
        // Compute global mean
        Double global_mean = 0;
        for(Int i = 0; i < mean_distance_percentile.size(); i++)
        {
            global_mean += mean_distance_percentile[i];
        }
        
        global_mean /= mean_distance_percentile.size();
        
#if IS_DEBUG_MU_TURN_MU
        cout << "YYYYYYYY global mean: " << global_mean << endl;
        
        // Write Global Mean
        string fileName3 = "";
        std::ostringstream oss3;
        oss3 << "Gen//Seq-TXT//" << "Summary" << "_gMean-" << g_qpInit  << ".txt";
        fileName3 = oss3.str();
        Char* pYUVFileName3 = fileName3.empty()? NULL: strdup(fileName3.c_str());
        FILE* mse_pFile3 = fopen (pYUVFileName3, "at");
        fprintf(mse_pFile3, "%s \t\t\t\t %f\n", g_input_FileName.c_str(), global_mean);
        fclose(mse_pFile3);
        // Write Global Mean
#endif
        
#if IS_LDP
        Double distance_threshold = (g_qpInit==22)? THRESHOLD_EPS_22:THRESHOLD_EPS_27;
#else
        Double distance_threshold = (g_qpInit==22)? THRESHOLD_EPS_B_22:THRESHOLD_EPS_B_27;
#endif
        if(global_mean > distance_threshold && global_mean < 100)
        {
            
#if IS_ENABLE_ACTUAL_LD
            isEpsilonMethodON = false;
#else
            isEpsilonMethodON = true;
#endif
                cout << " Epsilon METHOD TURNED OFF XXXX >>> <<< gggPPP " << endl;
//            isEpsilonMethodON = true;
#if IS_DEBUG_MU_TURN_MU
            cout << " Epsilon METHOD TURNED OFF XXXX >>> <<< gggPPP " << endl;
#endif
            
#if IS_DISABLE_TURN_ON_OFF
            isEpsilonMethodON = true;
    #if IS_DEBUG_MU_TURN_MU
                cout << " Epsilon METHOD TURNED OFF DISABLE  XXXX >>> <<< gggPPP " << endl;
    #endif
            
#endif
            
        }
        else{
            isEpsilonMethodON = true;
            cout << " Epsilon METHOD TURNED ON XXXX >>> <<< lolo " << endl;
#if IS_DEBUG_MU_TURN_MU
            cout << " Epsilon METHOD TURNED ON XXXX >>> <<< lolo " << endl;
#endif
        }        
    }
//............. Checking....
    
    if(isEpsilonMethodON)
    {
        
        //////
//        cout << "\n DEBUGXXXX start: " << start_for_i << endl;
//        for(UInt i = start_for_i; i <= last_frame_encoded; i++)
//        {
//            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
//            
//            cout << "DEBUGXXX: " << curr_mu_i_j << ", di: " <<distortion_in_sliding_window[i] << ", di-1: " << distortion_in_sliding_window[i-1] << ", sigma: " << sigma_squared_in_sliding_window[i] << endl;
//        }
        ////
        
    
//    for(UInt i = 1; i <= last_frame_encoded; i++)
    for(UInt i = start_for_i; i <= last_frame_encoded; i++)
    {
        // mu_pred_ref = Dpred / (Dref + sigma^2)
        Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
        mu_ij.push_back(curr_mu_i_j);
        
        
//        cout << "\npred=" << i <<  ", ref= " << i-1 << endl;
//        cout << "\npred=" << i <<  ", ref= " << i-1 << ", val: " << mu_ij.back() << endl;
        
#if GEN_MU_FILES
        if (start_prop_window == 88) {
            cout << "\nOUTPUTTING THE mu orig "  << start_for_i << " " << last_frame_encoded << endl;
            string fileName2 = "";
            std::ostringstream oss2;
            oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
            fileName2 = oss2.str();
            Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
            FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
            mult = mult*curr_mu_i_j;
            fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
            fclose(mse_pFile2);
        }
        
#endif
        
//        cout << "curr_mu_i_j for i_pred = " << i << ", j_ref = " << (i-1) << ", is: " << mu_ij.back() << endl;
    } // end for loop
        

// Hossam: use this to see the spectrum of all mu values
#if IS_DUMP_MU_VALUES
        dumpMuValues(mu_ij, start_for_i, last_frame_encoded, true);
#endif
    
    
    // Calculate epsilon_i
    Int gop_sz = 4;
    
    // Reset all the epsilon array to 0 -- four epsilons you want to compute
    epsilon_array.resize(gop_sz + 1);
    std::fill(epsilon_array.begin(), epsilon_array.end(), 0);

    
    static int multiples_of_i = 0;
    // for each eps from 0 to 4
    for(UInt i = 0; i <= gop_sz; i++)
    {
        Double eps = 1.0;
        Double multiplier = 1.0;
        UInt iShift = gop_sz;
        
//        if(i % 4 !=0)
//        {
//            iShift = 1;
//        }
        
//        cout << "Iterations for j " << jIters << ", i " << i << " , shift " << iShift << " start " << start_prop << endl;
        
#if IS_ADAPTIVE_PROPAGATION_LENGTH
        
        // your mu start index:
        Int start_index_mu = i + start_prop_window;
        
        // loop from your start index until your propogation length
        for (UInt j = start_index_mu; j < start_index_mu + g_pPropLength; j++) {
#else 
        for (UInt j = i + start_prop_window; j < i + iShift + start_prop_window; j++) {
#endif
            
//            cout << "\npred= " << (j+1) << ", ref= " << (j) << ", mu: " << mu_ij.at(j) <<  " , multiplier: " << multiplier << ", add: " << multiplier*mu_ij.at(j) << ", eps: " << eps;
            
#if IS_DUMP_THETA_I
            string fileName_theta = "";
            std::ostringstream oss_theta;
            oss_theta << "Gen//Seq-TXT//" << g_input_FileName << "_theta" << g_qpInit  << ".txt";
            fileName_theta = oss_theta.str();
            Char* pYUVFileName_theta = fileName_theta.empty()? NULL: strdup(fileName_theta.c_str());
            FILE* mse_pFile_theta = fopen (pYUVFileName_theta, "at");
            fprintf(mse_pFile_theta, "%f\n", multiplier*mu_ij.at(j));
            fclose(mse_pFile_theta);
#endif
            
            eps += multiplier*mu_ij.at(j);
            multiplier = mu_ij.at(j);
            
//            cout << ", after eps: " << eps << endl;
        } // end inner loop
            
#if IS_DUMP_THETA_I
            string fileName_theta = "";
            std::ostringstream oss_theta;
            oss_theta << "Gen//Seq-TXT//" << g_input_FileName << "_theta" << g_qpInit  << ".txt";
            fileName_theta = oss_theta.str();
            Char* pYUVFileName_theta = fileName_theta.empty()? NULL: strdup(fileName_theta.c_str());
            FILE* mse_pFile_theta = fopen (pYUVFileName_theta, "at");
            fprintf(mse_pFile_theta, "%f\n", 0.0);
            fclose(mse_pFile_theta);
#endif
        
//        cout << "epsilon of frame-" << i  << ", " << i % 4 << ", is " << epsilon_array.at(i) << endl;
//        cout << "\n" << endl;
        
        epsilon_array[i] = eps;
//        cout << "epsilon of frame-" << i  << ", " << i % 4 << ", is " << epsilon_array.at(i) << endl;

    }
    
    
    multiples_of_i = multiples_of_i + 4;
        
    
    
//    epsilon_array.resize(9);
//    std::fill(epsilon_array.begin(), epsilon_array.end(), 0);
//
//    // for each eps from 0 to 4
//    epsilon_array[8] = 1;
//    for (Int i = 8-1; i >= 0; i--) {
//        epsilon_array[i] = 1 + epsilon_array.at(i+1) * mu_ij.at(i);
//        
//        cout << "epsilon of frame-" << i << ", is " << epsilon_array.at(i) << endl;
//    }

    // empty up the mu(i, j) -- Dynamic
//    cout << "Empty the mu(i,j) to re-calculate based on my previous QP offset choice " << endl;
    mu_ij.clear();
    
    } // end if isEpsilon method
    else{
        
        Int gop_sz = 4;
        for(UInt i = 0; i <= gop_sz; i++)
        {
            epsilon_array[i] = -1;
        }
        
    } // epsilon method is off
        
    return;
}

    
    // pass the mu vector and it dumps it for you
Void TEncGOP::dumpMuValues(const std::vector<Double> &mu_ij, const UInt &start_for_i, const UInt &last_frame_encoded, bool isGroupBased) const
{
    
//        cout << "\nDumpMuValues: Size: " << mu_ij.size() << endl;
    
        string fileName_muExact = "";
        std::ostringstream oss_muExact;
        oss_muExact << "Gen//Seq-TXT//" << g_input_FileName << "_muExact" << g_qpInit  << ".txt";
        fileName_muExact = oss_muExact.str();
        Char* pYUVFileName_muExact = fileName_muExact.empty()? NULL: strdup(fileName_muExact.c_str());
        static Bool is_dump_mu_first_time = true;
        
    
        
        // if it is the first time, then loop all the mu you calculated; otherwise, just the last one
        if(is_dump_mu_first_time)
        {
            for(Int i = 0; i < mu_ij.size(); ++i)
            {
//                cout << "curr_mu_i_j for i_pred = " << (i+1) << ", j_ref = " << (i) << ", is: " << mu_ij.at(i) << endl;
                FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
                fprintf(mse_pFile_muExact, "%f\n", mu_ij.at(i));
                fclose(mse_pFile_muExact);
            }
            
            // Set it to false!
            is_dump_mu_first_time = false;
        }
        else if(isGroupBased) // write the last four values everytime in case of EpsilonPred
        {
            for(Int i = mu_ij.size() - 4; i < mu_ij.size(); ++i)
            {
//                cout << "curr_mu_i_j for i_pred = " << (i+1) << ", j_ref = " << (i) << ", is: " << mu_ij.at(i) << endl;
                FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
                fprintf(mse_pFile_muExact, "%f\n", mu_ij.at(i));
                fclose(mse_pFile_muExact);
            }
            
        }
        else{
//            cout << "curr_mu_i_j for i_pred = " << last_frame_encoded << ", j_ref = " << (last_frame_encoded-1) << ", is: " << mu_ij.back() << endl;
            FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
            fprintf(mse_pFile_muExact, "%f\n", mu_ij.back());
            fclose(mse_pFile_muExact);
        }
    
    
} // end dumpMuValues
    

    
    // pass the mu vector and it dumps it for you
Void TEncGOP::dumpMuValuesMult(const std::vector<Double> &mu_ij, const std::vector<Double> &mu_ij_ref1, const UInt &start_for_i, const UInt &last_frame_encoded, bool isGroupBased) const
{
        
//            cout << "\nDumpMuValues: Size: " << mu_ij.size() << ", siz1: " << mu_ij_ref1.size() << endl;
    
        string fileName_muExact = "";
        std::ostringstream oss_muExact;
        oss_muExact << "Gen//Seq-TXT//" << g_input_FileName << "_muExact" << g_qpInit  << ".txt";
        
        fileName_muExact = oss_muExact.str();
        Char* pYUVFileName_muExact = fileName_muExact.empty()? NULL: strdup(fileName_muExact.c_str());
        static Bool is_dump_mu_first_time = true;
    
        // if it is the first time, then loop all the mu you calculated; otherwise, just the last one
        if(is_dump_mu_first_time)
        {
            // dump mu0
            for(Int i = 0; i < mu_ij.size(); ++i)
            {
//                cout << "curr_mu_i_j for i_pred = " << (i+1) << ", j_ref = " << (i) << ", is: " << mu_ij.at(i) << endl;
                FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
                fprintf(mse_pFile_muExact, "%f\n", mu_ij.at(i));
                fclose(mse_pFile_muExact);
            }
            
            // Transition to mu1
            oss_muExact.clear(); oss_muExact.str("");
            oss_muExact << "Gen//Seq-TXT//" << g_input_FileName << "_muExact_Ref1_" << g_qpInit  << ".txt";
            fileName_muExact = oss_muExact.str();
            pYUVFileName_muExact = fileName_muExact.empty()? NULL: strdup(fileName_muExact.c_str());
            
            // dump mu1
            for(Int i = 0; i < mu_ij_ref1.size(); ++i)
            {
//                cout << "curr_mu_i_j_ref1 for i_pred = " << (i + 1) << ", j_ref = " << (i + 1 + getLDOffsetRef2(i + 1)) << ", is: " << mu_ij_ref1.at(i) << endl;
                FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
                fprintf(mse_pFile_muExact, "%f\n", mu_ij_ref1.at(i));
                fclose(mse_pFile_muExact);
            }

            
            // Set it to false!
            is_dump_mu_first_time = false;
        }
        else if(isGroupBased) // write the last four values everytime in case of EpsilonPred
        {
            for(Int i = mu_ij.size() - 4; i < mu_ij.size(); ++i)
            {
                //                cout << "curr_mu_i_j for i_pred = " << (i+1) << ", j_ref = " << (i) << ", is: " << mu_ij.at(i) << endl;
                FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
                fprintf(mse_pFile_muExact, "%f\n", mu_ij.at(i));
                fclose(mse_pFile_muExact);
            }
            
        }
        else{
            // dump mu0
            //            cout << "curr_mu_i_j for i_pred = " << last_frame_encoded << ", j_ref = " << (last_frame_encoded-1) << ", is: " << mu_ij.back() << endl;
            FILE* mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
            fprintf(mse_pFile_muExact, "%f\n", mu_ij.back());
            fclose(mse_pFile_muExact);
            
            // Transition to mu1
            oss_muExact.clear(); oss_muExact.str("");
            oss_muExact << "Gen//Seq-TXT//" << g_input_FileName << "_muExact_Ref1_" << g_qpInit  << ".txt";
            fileName_muExact = oss_muExact.str();
            pYUVFileName_muExact = fileName_muExact.empty()? NULL: strdup(fileName_muExact.c_str());
            
            // dump mu1
            mse_pFile_muExact = fopen (pYUVFileName_muExact, "at");
            fprintf(mse_pFile_muExact, "%f\n", mu_ij_ref1.back());
            fclose(mse_pFile_muExact);

        }
        
        
} // end dumpMuValuesMult
    

// Calculate current epsilon in the mu prediction method
Void TEncGOP::calculateCurrentEpsilonMu(TComPic *pcPic)
{
    Int curr_poc = pcPic->getPOC();
    
//      displayDAndSigmaSlidingWindowList(progress_in_sliding_window);
    // visit the past
    //    UInt start_loop_from = progress_in_sliding_window - sliding_window_length;
    // Calculate mu(i, j)
//    cout << "\n calculateCurrentEpsilonMu start " << endl;
//    cout << " D list length " << distortion_in_sliding_window.size() << endl;

    Double mult = 1;
    
    
    UInt last_frame_to_be_encoded = curr_poc + 1;
    
    
////////////// Checker loop
    
    // initial value of end_prop_window
    UInt start_for_i = m_pcEncTop->getSceneChangeCoder()->getLastSC()==-1? 1:m_pcEncTop->getSceneChangeCoder()->getLastSC()+1;
    UInt last_frame_encoded = curr_poc;
    
    // high bitrates and at frame POC 20, where you calculated mu(9) -> mu(21)
//    if((g_qpInit == 22 || g_qpInit == 27) && last_frame_encoded == start_for_i + 20)
    // XXXXX need to remove that after
//    if(last_frame_encoded == start_for_i + 20)
    if((g_qpInit == 22 || g_qpInit == 27) && last_frame_encoded == start_for_i + 20)
//    if(last_frame_encoded == start_for_i + 20)
    {
        std::vector<Double> mu_ijChecker;
        
        // Calculate the mu's
        for(UInt i = start_for_i; i <= last_frame_encoded; i++)
        {
            // mu_pred_ref = Dpred / (Dref + sigma^2)
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
            mu_ijChecker.push_back(curr_mu_i_j);
            
#if IS_DEBUG_MU_TURN_MU
            // wanna see the mu's
            cout << "\nOUTPUTTING THE mu orig i, mu_ij " << mu_ijChecker.size()-1 << ", " << mu_ijChecker[mu_ijChecker.size()-1] << endl;
            string fileName2 = "";
            std::ostringstream oss2;
            oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
            fileName2 = oss2.str();
            Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
            FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
            mult = mult*curr_mu_i_j;
            fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
            fclose(mse_pFile2);
#endif
            
        }
        
        // Declare the distance vector
        Int nIter = 3;
        std::vector<Double> distance_percentile(4);
        std::vector<Double> mean_distance_percentile;
         Int to_i_iters = 9+4*nIter;
//        Int to_i_iters = 10+4*nIter;
//        for(Int i = 10; i < to_i_iters; i++)
        for(Int i = 9; i < to_i_iters; i++)
        {
            if(i % getGOPSize() == 0)
            {
                Double sum = 0;
                for (Int j = i; j >= i-3; j--)
                {
                    distance_percentile[i] = 100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1];
                    sum += distance_percentile[i];
//                    distance_percentile.push_back(100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1]);
//                    sum += distance_percentile.back();

                }
                
                // mean locally for every four
                Double mean = sum / distance_percentile.size();
                mean_distance_percentile.push_back(mean);
            }
        }
        
        // Compute global mean
        Double global_mean = 0;
        for(Int i = 0; i < mean_distance_percentile.size(); i++)
        {
            global_mean += mean_distance_percentile[i];
        }
        
        global_mean /= mean_distance_percentile.size();
        
#if IS_DEBUG_MU_TURN_MU
        cout << "YYYYYYYY global mean: " << global_mean << endl;
        
        // Write Global Mean
        string fileName3 = "";
        std::ostringstream oss3;
        oss3 << "Gen//Seq-TXT//" << "Summary" << "_gMean-" << g_qpInit  << ".txt";
        fileName3 = oss3.str();
        Char* pYUVFileName3 = fileName3.empty()? NULL: strdup(fileName3.c_str());
        FILE* mse_pFile3 = fopen (pYUVFileName3, "at");
        fprintf(mse_pFile3, "%s \t\t\t\t %f\n", g_input_FileName.c_str(), global_mean);
        fclose(mse_pFile3);
        // Write Global Mean
#endif 
        
#if IS_LDP
        Double distance_threshold = (g_qpInit==22)? THRESHOLD_MU_22:THRESHOLD_MU_27;
#else
        Double distance_threshold = (g_qpInit==22)? THRESHOLD_MU_B_22:THRESHOLD_MU_B_27;
#endif
        if(global_mean > distance_threshold && global_mean < 100)
        {
#if IS_ENABLE_ACTUAL_LD
            isMuMethodON = false;
#else
       isMuMethodON = true;
#endif
            
#if IS_DEBUG_MU_TURN_MU
            cout << " MU METHOD TURNED OFF XXXX >>> <<< gggPPP " << endl;
#endif
        }
        else{
            isMuMethodON = true;
#if IS_DEBUG_MU_TURN_MU
            cout << " MU METHOD TURNED ON XXXX >>> <<< lolo " << endl;
#endif
        }
        
        
        isMuMethodON = true;
        cout << "Always setting the mu method to true " << endl;
    }
//////////////////////
    
    // Sala7 on its own
//    if(pcPic->getPOC() == 21)
//    {
//        // POC=2
//        // w1
//        
//        // With respect to I
//        //           Int test_pred_poc = 2;
//        //           Int test_ref1_poc = 1; Int test_ref2_poc = 0;
//        
//        
//        // With respect to P
//        static int off_ref [] = {-5, -2, -3, -4};
//        Int test_pred_poc = 17;
//        Int fetch_index = test_pred_poc % 4 == 0? 3: test_pred_poc % 4 - 1;
//        Int test_ref1_poc = test_pred_poc - 1; Int test_ref2_poc = test_pred_poc + off_ref[fetch_index];
//        
//        
//        Double w1 = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(test_pred_poc);
//        
//        // w2
//        Double w2 = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(test_pred_poc);
//        
//        // Distortions
//        Double Dpre  = distortion_in_sliding_window[test_pred_poc];
//        Double Dref1 = distortion_in_sliding_window[test_ref1_poc];
//        Double Dref2 = distortion_in_sliding_window[test_ref2_poc];
//        Double Dpre0 = sigma_squared_in_sliding_window[test_pred_poc];
//        
//        // Original sigma squared
//        Double sigma1 = 12;
//        Double sigma2 = 12;
//        
//        // calculate mu1 for POC=2
//        Double mu1 = (w1*w1*Dpre) / ( w1*w1*(Dref1 + sigma1 ) + w2*w2*(Dref2 + sigma2));
//        
//        // calculate mu2 for POC=2
//        Double mu2 = (w2*w2*Dpre) / ( w1*w1*(Dref1 + sigma1 ) + w2*w2*(Dref2 + sigma2));
//        
//        // Dump Dref1
//        string fileName = "";
//        std::ostringstream oss;
//        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref1MSE-" << g_qpInit  << ".txt";
//        fileName = oss.str();
//        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//        FILE* mse_pFile = fopen (pYUVFileName, "at");
//        //                   fprintf(mse_pFile, "%6.4lf \t %10d \n", MSEyuvframe[COMPONENT_Y], uibits);
//        fprintf(mse_pFile, "%6.4lf \n", Dref1);
//        fclose(mse_pFile);
//        
//        // Dump Dref2
//        oss.str(""); oss.clear();
//        oss << "Gen//Seq-TXT//" << g_input_FileName << "_ref2MSE-" << g_qpInit << ".txt";
//        fileName = oss.str();
//        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//        mse_pFile = fopen (pYUVFileName, "at");
//        fprintf(mse_pFile, "%6.4lf \n", Dref2);
//        fclose(mse_pFile);
//        
//        // Dump Dpre
//        oss.str(""); oss.clear();
//        oss << "Gen//Seq-TXT//" << g_input_FileName << "_predMSE-" << g_qpInit  << ".txt";
//        fileName = oss.str();
//        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
//        mse_pFile = fopen (pYUVFileName, "at");
//        fprintf(mse_pFile, "%6.4lf \n", Dpre);
//        fclose(mse_pFile);
//        
//        
//    } // end Sala7
    
    
    if(isMuMethodON)
    {
        
        
#if IS_DUMP_MU_VALUES
        std::vector <Double> mu_ij_dumper;
        
        for(UInt i = start_for_i; i <= last_frame_encoded; ++i)
        {
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
            mu_ij_dumper.push_back(curr_mu_i_j);
        }
        
#if IS_INTER_DEP_MULTIPLE_REF
        std::vector <Double> mu_ij_dumper_ref1;
        
        // Here you need to work on integerating relativePOC
        for(UInt i = start_for_i; i <= last_frame_encoded; ++i)
        {
            Int offset = getLDOffsetRef2(i);
            if(i == 1)
                mu_ij_dumper_ref1.push_back(0);
            else
            {
                Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i + offset] + sigma_squared_in_sliding_window_Ref1[i]);
                mu_ij_dumper_ref1.push_back(curr_mu_i_j);
            }
        }
        
        dumpMuValuesMult(mu_ij_dumper, mu_ij_dumper_ref1, start_for_i, last_frame_encoded, false);
        mu_ij_dumper_ref1.clear();

// one reference only
#else
        dumpMuValues(mu_ij_dumper, start_for_i, last_frame_encoded, false);
#endif // end multiple reference if

                mu_ij_dumper.clear();
#endif
        
        //    cout << "last frame to be encoded " << last_frame_to_be_encoded << endl;
        for(UInt i = last_frame_to_be_encoded - 3; i < last_frame_to_be_encoded; i++)
        {
            //         cout << "pred = " << i << " ref " << i-1 << endl;
            // mu_pred_ref = Dpred / (Dref + sigma^2)
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
            mu_ij.push_back(curr_mu_i_j);
            
#if GEN_MU_FILES
            if (start_prop_window_mu == 88) {
                cout << "\nOUTPUTTING THE mu orig " << endl;
                string fileName2 = "";
                std::ostringstream oss2;
                oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
                fileName2 = oss2.str();
                Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
                FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
                mult = mult*curr_mu_i_j;
                fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
                fclose(mse_pFile2);
            }
            
#endif
        } // end for loop
        
        
#if IS_ADAPTIVE_PROPAGATION_LENGTH
        // starts from because min propogation length is 4
        Int pos;
        for(Int iter = 4; iter <= g_pPropLength; ++iter)
        {
            pos = (!(iter & 3))? 4:std::max(1, --pos);
//            cout << "POSition after " << pos << " iter: " << iter  << " bitwise " <<  (iter & 3) << endl;
            
            // push (mu(i-4, i-5), mu(i-3, i-4), mu(i-2, i-3), mu(i-1, i-2)), then cycle
            Double curr_mu_i_j = distortion_in_sliding_window[last_frame_to_be_encoded-pos] / (distortion_in_sliding_window[last_frame_to_be_encoded-pos-1] + sigma_squared_in_sliding_window[last_frame_to_be_encoded-pos]);
            mu_ij.push_back(curr_mu_i_j);
            
        }
        
#else
        // push the last item (mu(i-4, i-5))
        Double curr_mu_i_j = distortion_in_sliding_window[last_frame_to_be_encoded-4] / (distortion_in_sliding_window[last_frame_to_be_encoded-5] + sigma_squared_in_sliding_window[last_frame_to_be_encoded-4]);
        mu_ij.push_back(curr_mu_i_j);
#endif
        
        
        //    cout << "pred = " << last_frame_to_be_encoded-4 << " ref " << last_frame_to_be_encoded-5 << endl;
        
        // Calculate epsilon_i
        Int gop_sz = 4;
        
        // Reset all the epsilon array to 0 -- four epsilons you want to compute
        epsilon_array.resize(gop_sz + 1);
        std::fill(epsilon_array.begin(), epsilon_array.end(), 0);
        
        Double eps = 1.0;
        Double multiplier = 1.0;
        
#if IS_ADAPTIVE_PROPAGATION_LENGTH
        for(UInt j = 0; j < g_pPropLength; ++j)
#else
        for(UInt j = 0; j < 4; j++)
#endif
        {
            
#if IS_DUMP_THETA_I
            string fileName_theta = "";
            std::ostringstream oss_theta;
            oss_theta << "Gen//Seq-TXT//" << g_input_FileName << "_thetaMu" << g_qpInit  << ".txt";
            fileName_theta = oss_theta.str();
            Char* pYUVFileName_theta = fileName_theta.empty()? NULL: strdup(fileName_theta.c_str());
            FILE* mse_pFile_theta = fopen (pYUVFileName_theta, "at");
            fprintf(mse_pFile_theta, "%f\n", multiplier*mu_ij.at(j));
            fclose(mse_pFile_theta);
#endif
            
            eps += multiplier*mu_ij.at(j);
            
            
//            cout  << j << ") Eps so far:  " << eps << ", theta " << multiplier*mu_ij.at(j)  << ", mu(j):  " << mu_ij.at(j) << endl;
            multiplier *= mu_ij.at(j);
//            multiplier = mu_ij.at(j);
            
            
        }
        
//        cout  << (g_pPropLength-1) << ") Eps so far:  " << eps << ", theta " << multiplier  << ", mu(j):  " << mu_ij.at((g_pPropLength-1)) << endl;
        epsilon_array[0] = eps;
        
        
#if IS_DUMP_THETA_I
        string fileName_theta = "";
        std::ostringstream oss_theta;
        oss_theta << "Gen//Seq-TXT//" << g_input_FileName << "_thetaMu" << g_qpInit  << ".txt";
        fileName_theta = oss_theta.str();
        Char* pYUVFileName_theta = fileName_theta.empty()? NULL: strdup(fileName_theta.c_str());
        FILE* mse_pFile_theta = fopen (pYUVFileName_theta, "at");
        fprintf(mse_pFile_theta, "%f\n", 0.0);
        fclose(mse_pFile_theta);
#endif

#if IS_DUMP_EPSILON_I
        string fileName_epsilon = "";
        std::ostringstream oss_epsilon;
        oss_epsilon << "Gen//Seq-TXT//" << g_input_FileName << "_epsilonMu" << g_qpInit  << ".txt";
        fileName_epsilon = oss_epsilon.str();
        Char* pYUVFileName_epsilon = fileName_epsilon.empty()? NULL: strdup(fileName_epsilon.c_str());
        FILE* pFile_epsilon = fopen(pYUVFileName_epsilon, "at");
        fprintf(pFile_epsilon, "%f\n", epsilon_array.front());
        fclose(pFile_epsilon);
#endif
        
        //    cout << "Empty the mu(i,j) to re-calculate based on my previous QP offset choice " << endl;
        mu_ij.clear();
    } // end if isMuMethodON
    else
    {
        epsilon_array[0] = -1;
    }
    
    
    return;
}
    


    // Calculate current epsilon in the mu prediction method
Void TEncGOP::calculateCurrentEpsilonMuMult(TComPic *pcPic)
{
        Int curr_poc = pcPic->getPOC();
        
        //      displayDAndSigmaSlidingWindowList(progress_in_sliding_window);
        // visit the past
        //    UInt start_loop_from = progress_in_sliding_window - sliding_window_length;
        // Calculate mu(i, j)
        //    cout << "\n calculateCurrentEpsilonMu start " << endl;
        //    cout << " D list length " << distortion_in_sliding_window.size() << endl;
        Double mult = 1;
    
        
        UInt last_frame_to_be_encoded = curr_poc + 1;
        
        
        ////////////// Checker loop
        
        // initial value of end_prop_window
        UInt start_for_i = m_pcEncTop->getSceneChangeCoder()->getLastSC()==-1? 1:m_pcEncTop->getSceneChangeCoder()->getLastSC()+1;
        UInt last_frame_encoded = curr_poc;
        
        // high bitrates and at frame POC 20, where you calculated mu(9) -> mu(21)
        //    if((g_qpInit == 22 || g_qpInit == 27) && last_frame_encoded == start_for_i + 20)
        // XXXXX need to remove that after
        if((g_qpInit == 22 || g_qpInit == 27) && last_frame_encoded == start_for_i + 20)
            //    if(last_frame_encoded == start_for_i + 20)
        {
            std::vector<Double> mu_ijChecker;
            
            // Calculate the mu's
            for(UInt i = start_for_i; i <= last_frame_encoded; i++)
            {
                // mu_pred_ref = Dpred / (Dref + sigma^2)
                Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
                mu_ijChecker.push_back(curr_mu_i_j);
                
#if IS_DEBUG_MU_TURN_MU
                // wanna see the mu's
                cout << "\nOUTPUTTING THE mu orig i, mu_ij " << mu_ijChecker.size()-1 << ", " << mu_ijChecker[mu_ijChecker.size()-1] << endl;
                string fileName2 = "";
                std::ostringstream oss2;
                oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
                fileName2 = oss2.str();
                Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
                FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
                mult = mult*curr_mu_i_j;
                fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
                fclose(mse_pFile2);
#endif
                
            }
            
            // Declare the distance vector
            Int nIter = 3;
            std::vector<Double> distance_percentile(4);
            std::vector<Double> mean_distance_percentile;
            Int to_i_iters = 9+4*nIter;
            //        Int to_i_iters = 10+4*nIter;
            //        for(Int i = 10; i < to_i_iters; i++)
            for(Int i = 9; i < to_i_iters; i++)
            {
                if(i % getGOPSize() == 0)
                {
                    Double sum = 0;
                    for (Int j = i; j >= i-3; j--)
                    {
                        distance_percentile[i] = 100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1];
                        sum += distance_percentile[i];
                        //                    distance_percentile.push_back(100.0*fabs(mu_ijChecker[j] - mu_ijChecker[j-1])/mu_ijChecker[j-1]);
                        //                    sum += distance_percentile.back();
                        
                    }
                    
                    // mean locally for every four
                    Double mean = sum / distance_percentile.size();
                    mean_distance_percentile.push_back(mean);
                }
            }
            
            // Compute global mean
            Double global_mean = 0;
            for(Int i = 0; i < mean_distance_percentile.size(); i++)
            {
                global_mean += mean_distance_percentile[i];
            }
            
            global_mean /= mean_distance_percentile.size();
            
#if IS_DEBUG_MU_TURN_MU
            cout << "YYYYYYYY global mean: " << global_mean << endl;
            
            // Write Global Mean
            string fileName3 = "";
            std::ostringstream oss3;
            oss3 << "Gen//Seq-TXT//" << "Summary" << "_gMean-" << g_qpInit  << ".txt";
            fileName3 = oss3.str();
            Char* pYUVFileName3 = fileName3.empty()? NULL: strdup(fileName3.c_str());
            FILE* mse_pFile3 = fopen (pYUVFileName3, "at");
            fprintf(mse_pFile3, "%s \t\t\t\t %f\n", g_input_FileName.c_str(), global_mean);
            fclose(mse_pFile3);
            // Write Global Mean
#endif
            
#if IS_LDP
            Double distance_threshold = (g_qpInit==22)? THRESHOLD_MU_22:THRESHOLD_MU_27;
#else
            Double distance_threshold = (g_qpInit==22)? THRESHOLD_MU_B_22:THRESHOLD_MU_B_27;
#endif
            if(global_mean > distance_threshold && global_mean < 100)
            {
#if IS_ENABLE_ACTUAL_LD
                isMuMethodON = false;
#else
                isMuMethodON = true;
#endif
                
#if IS_DEBUG_MU_TURN_MU
                cout << " MU METHOD TURNED OFF XXXX >>> <<< gggPPP " << endl;
#endif
            }
            else{
                isMuMethodON = true;
#if IS_DEBUG_MU_TURN_MU
                cout << " MU METHOD TURNED ON XXXX >>> <<< lolo " << endl;
#endif
            }
            
        } // end isMuMethodCheckON
    
        //////////////////////
    
        isMuMethodON = true;
        cout << "Always turning the mu method on!" << endl;
        if(isMuMethodON)
        {
            
            
#if IS_DUMP_MU_VALUES
            std::vector <Double> mu_ij_dumper;
            
            for(UInt i = start_for_i; i <= last_frame_encoded; ++i)
            {
                Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
                mu_ij_dumper.push_back(curr_mu_i_j);
            }
            
#if IS_INTER_DEP_MULTIPLE_REF
            std::vector <Double> mu_ij_dumper_ref1;
            
            // Here you need to work on integerating relativePOC
            for(UInt i = start_for_i; i <= last_frame_encoded; ++i)
            {
                Int offset = getLDOffsetRef2(i);
                if(i == 1)
                    mu_ij_dumper_ref1.push_back(0);
                else
                {
                    Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i + offset] + sigma_squared_in_sliding_windo/w_Ref1[i]);
                    mu_ij_dumper_ref1.push_back(curr_mu_i_j);
                }
            }

            // DEBUG all parameters to compute epsilon
//            displayDAndSigmaSlidingWindowList(pcPic->getPOC());
//            displayCodingDepList(mu_ij_dumper, mu_ij_dumper_ref1);
//            displayReferenceUtilizations(pcPic->getPOC());

            
            dumpMuValuesMult(mu_ij_dumper, mu_ij_dumper_ref1, start_for_i, last_frame_encoded, false);
            mu_ij_dumper_ref1.clear();
            
            // one reference only
#else
            dumpMuValues(mu_ij_dumper, start_for_i, last_frame_encoded, false);
#endif // end multiple reference if
            
            mu_ij_dumper.clear();
#endif
           
            //    cout << "last frame to be encoded " << last_frame_to_be_encoded << endl; // last_frame_encoded = cur_poc + 1
            
            // Mu and Epsilon calculation
//            cout << "w1 Size: " << (m_pcSliceEncoder->reference1_utilization_rates_perFrame.size()) << ", w2 Size: " << (m_pcSliceEncoder->reference2_utilization_rates_perFrame).size() << endl;
//            cout << "sigma1 Size: " << sigma_squared_in_sliding_window.size() << ", sigma2 Size: " << sigma_squared_in_sliding_window_Ref1.size() << endl;
            
            // Calculate epsilon_i
            Int gop_sz = 4;
            
            // Reset all the epsilon array to 0 -- four epsilons you want to compute
            epsilon_array.resize(gop_sz + 1);
            std::fill(epsilon_array.begin(), epsilon_array.end(), 0);
            
            
//            epsilon_array[0] = calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
//            cout << "\n" << last_frame_to_be_encoded << ") Final Epsilon " << epsilon_array[0] << endl;
            
//            epsilon_array[0] = mock_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);

            
            // Combined Recurive + mu squared:
//            Double t = mock_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded)
//                      + mock3_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
//            epsilon_array[0] = t;
            
            // Weighted version with multiple references
            epsilon_array[0] = calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
//            cout << "The value of epsilon is: " << epsilon_array[0] << endl;
//            
//            epsilon_array[0] = mock_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
//            cout << "The value of epsilon is: " << epsilon_array[0] << endl;
//            exit(0);
            
            // muSquared:
//            epsilon_array[0] = mock2_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
            
            // Correct
//            epsilon_array[0] = mock_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
            
//            epsilon_array[0] = mock2_calculateCurrentEpsilonMuMultHelper(pcPic, last_frame_to_be_encoded);
//            cout << "teee bebeee " << t  << ", mock2: " << epsilon_array[0] << endl;
//            exit(0);
            
#if IS_DUMP_EPSILON_I
            string fileName_epsilon = "";
            std::ostringstream oss_epsilon;
            oss_epsilon << "Gen//Seq-TXT//" << g_input_FileName << "_epsilonMu" << g_qpInit  << ".txt";
            fileName_epsilon = oss_epsilon.str();
            Char* pYUVFileName_epsilon = fileName_epsilon.empty()? NULL: strdup(fileName_epsilon.c_str());
            FILE* pFile_epsilon = fopen(pYUVFileName_epsilon, "at");
            fprintf(pFile_epsilon, "%f\n", epsilon_array.front());
            fclose(pFile_epsilon);
#endif
          
        } // end if isMuMethodON
        else
        {
            epsilon_array[0] = -1;
        }
        
        
        return;
}
    
// Calculates Epsilon Recursively from POC >= 8
Double TEncGOP::calculateCurrentEpsilonMuMultHelper(TComPic *pcPic, Int current_i, Int prev_i, Int level)
{
    
    if(level == 5)
    {
        return 1.0;
    }
    else if(current_i >= 8 && current_i % 4 == 0)
    {
        
        Double mu = 1, w = 1;
        Double sumW8t = 0;
        
        Int i = current_i + 1;
        Int j = current_i;
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window.at(i));
//        w  = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i)/100.0;
        
        
        // (1) normalize weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) / sumW8t;
//        w  = 1;
//        
//        cout << "\nmu( " << (current_i + 1) << ", " << current_i << ") -- Level: " << level  << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w << ", " << ", reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i)  ;
        Double a1 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 1, current_i, (level + 1))*mu*w;
        
        i = current_i + 2;
        j = current_i;
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window_Ref1.at(i));

        // (2) normalize the weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i) / sumW8t;
//        w = 1;
//        
//        cout << "\nmu( " << (current_i + 2) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w << ", " << "reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        Double a2 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 2, current_i, (level + 1))*mu*w;

        i = current_i + 3;
        j = current_i;
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window_Ref1.at(i));
        
        // (3) normalize the weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i) / sumW8t;
//        w = 1;
        
//        cout << "\nmu( " << (current_i + 3) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w << ", " << "reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        Double a3 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 3, current_i, (level + 1))*mu*w;

        i = current_i + 4;
        j = current_i;
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window_Ref1.at(i));
        
        // (4) normalize the weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i) / sumW8t;
//        w = 1;
        
//        cout << "\nmu( " << (current_i + 4) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w << ", " << "reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        Double a4 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 4, current_i, (level + 1))*mu*w;

        i = current_i + 5;
        j = current_i;
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window_Ref1.at(i));
        
        // (5) normalize weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i) / sumW8t;
//        w = 1;
        
//        cout << "\nmu( " << (current_i + 5) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w << ", " << "reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        Double a5 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 5, current_i, (level + 1))*mu*w;
        
        
//        cout << "\na1 " << a1 << " a2: " << a2 << " a3: " << a3 << " a4: " << a4 << " a5: " << a5 << endl;
        return 1.0 + a1 + a2 + a3 + a4 + a5;
    }
    else
    {
        Double mu = 1, w = 1;
        Double sumW8t = 0;
        
        Int i = current_i + 1;
        Int j = current_i;
        
        getPredRefIndexMult(pcPic->getPOC()+1, i, j);
        mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window.at(i));
        
        
        // normalize the weights
        sumW8t = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) + m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i);
        w      = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) / sumW8t;
//        w = 1;
        
//        cout << "\nmu( " << (current_i+1) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w
//        << ", reference1_rates_perFrame.at(i): " << m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(i) << ", reference2_rates_perFrame.at(i): " << m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i) << ", sum: " << ( w + .001*m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(i)) << endl;
        
        Double a1 = calculateCurrentEpsilonMuMultHelper(pcPic, current_i + 1, current_i, (level + 1))*mu*w;
        
        
//        cout << "a1 " << a1 << endl;
        return 1.0 + a1;
    }
        
} // end method
    
    

    
    // Calculates Epsilon Recursively from POC >= 8
    Double TEncGOP::mock_calculateCurrentEpsilonMuMultHelper(TComPic *pcPic, Int current_i, Int prev_i, Int level, Double eps)
    {
        
//        cout << "\nI am INIT current, prev " << current_i << " " << prev_i << ", level: " << level << endl;
        
        if(level == 5)
        {
            return 1.0;
        }
        else
        {
            Double mu = 1, w = 1;
            
            Int i = current_i + 1;
            Int j = current_i;
            
            getPredRefIndexMult(pcPic->getPOC()+1, i, j);
            mu = distortion_in_sliding_window.at(i) / (distortion_in_sliding_window.at(j) + sigma_squared_in_sliding_window.at(i));
            
            
//            cout << "\nmu( " << (current_i+1) << ", " << current_i << ") -- Level: " << level  << ", " << ", i: " << i << ", j: " << j << ", mu: " << mu << " " << ", w " << w <<  " " << eps << endl;
            
           Double a1 = 1 + mu*mock_calculateCurrentEpsilonMuMultHelper(pcPic, 1 +  current_i, current_i, 1 + level, eps);
            
//            cout << "a1: " << a1 << endl;
            return a1;
        }
        
    }
    
    // Calculates Epsilon Recursively from POC >= 8
    Double TEncGOP::mock3_calculateCurrentEpsilonMuMultHelper(TComPic *pcPic, Int current_i, Int prev_i, Int level)
    {
        
        UInt last_frame_to_be_encoded = pcPic->getPOC() + 1;
        mu_ij.clear();
        //    cout << "last frame to be encoded " << last_frame_to_be_encoded << endl;
        for(UInt i = last_frame_to_be_encoded - 3; i < last_frame_to_be_encoded; i++)
        {
            //         cout << "pred = " << i << " ref " << i-1 << endl;
            // mu_pred_ref = Dpred / (Dref + sigma^2)
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
//            cout << "pred = " << i << " ref " << i-1 << ", mu: " << curr_mu_i_j << endl;
            mu_ij.push_back(curr_mu_i_j);
        } // end for loop
        
        
        // push the last item (mu(i-4, i-5))
        
        
        Double curr_mu_i_j = distortion_in_sliding_window[last_frame_to_be_encoded-4] / (distortion_in_sliding_window[last_frame_to_be_encoded-5] + sigma_squared_in_sliding_window[last_frame_to_be_encoded-4]);
        mu_ij.push_back(curr_mu_i_j);
        
//        cout << "pred = " << last_frame_to_be_encoded-4 << " ref " << last_frame_to_be_encoded-4-1 << ", mu: " << curr_mu_i_j << endl;
        
        Double a2 = 0  + mu_ij[0]*mu_ij[1];
        Double a3 = a2 + mu_ij[1]*mu_ij[2];
        Double a4 = a3 + mu_ij[2]*mu_ij[3];
        
        mu_ij.clear();
        
        return a4;

        
    }

    
    // Calculates Epsilon Recursively from POC >= 8
    Double TEncGOP::mock2_calculateCurrentEpsilonMuMultHelper(TComPic *pcPic, Int current_i, Int prev_i, Int level)
    {
        
        UInt last_frame_to_be_encoded = pcPic->getPOC() + 1;
        mu_ij.clear();
        //    cout << "last frame to be encoded " << last_frame_to_be_encoded << endl;
        for(UInt i = last_frame_to_be_encoded - 3; i < last_frame_to_be_encoded; i++)
        {
            //         cout << "pred = " << i << " ref " << i-1 << endl;
            // mu_pred_ref = Dpred / (Dref + sigma^2)
            Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
             cout << "pred = " << i << " ref " << i-1 << ", mu: " << curr_mu_i_j << endl;
            mu_ij.push_back(curr_mu_i_j);
        } // end for loop
        
        
        // push the last item (mu(i-4, i-5))
        
        
        Double curr_mu_i_j = distortion_in_sliding_window[last_frame_to_be_encoded-4] / (distortion_in_sliding_window[last_frame_to_be_encoded-5] + sigma_squared_in_sliding_window[last_frame_to_be_encoded-4]);
        mu_ij.push_back(curr_mu_i_j);
        
        cout << "pred = " << last_frame_to_be_encoded-4 << " ref " << last_frame_to_be_encoded-4-1 << ", mu: " << curr_mu_i_j << endl;
        
        Double eps = 1.0;
        Double multiplier = 1.0;
        
        for(UInt j = 0; j < 4; j++)
        {
            
            eps += multiplier*mu_ij.at(j);
            multiplier = mu_ij.at(j);
            
            cout << "Eps j " << eps << ", " << j << endl;
        }
        
        
        return eps;
        
    }
    
// above using isMuMethodON
// Calculate current epsilon in the mu prediction method
//Void TEncGOP::calculateCurrentEpsilonMu(TComPic *pcPic)
//{
//    Int curr_poc = pcPic->getPOC();
//
//    //      displayDAndSigmaSlidingWindowList(progress_in_sliding_window);
//    // visit the past
//    //    UInt start_loop_from = progress_in_sliding_window - sliding_window_length;
//    // Calculate mu(i, j)
//    //    cout << "\n calculateCurrentEpsilonMu start " << endl;
//    //    cout << " D list length " << distortion_in_sliding_window.size() << endl;
//#if GEN_MU_FILES
//    Double mult = 1;
//#endif
//    
//    UInt last_frame_to_be_encoded = curr_poc + 1;
//    
//    //    cout << "last frame to be encoded " << last_frame_to_be_encoded << endl;
//    for(UInt i = last_frame_to_be_encoded - 3; i < last_frame_to_be_encoded; i++)
//    {
//        //         cout << "pred = " << i << " ref " << i-1 << endl;
//        // mu_pred_ref = Dpred / (Dref + sigma^2)
//        Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
//        mu_ij.push_back(curr_mu_i_j);
//        
//#if GEN_MU_FILES
//        if (start_prop_window_mu == 88) {
//            cout << "\nOUTPUTTING THE mu orig " << endl;
//            string fileName2 = "";
//            std::ostringstream oss2;
//            oss2 << "Gen//Seq-TXT//" << g_input_FileName << "_mu" << g_qpInit  << ".txt";
//            fileName2 = oss2.str();
//            Char* pYUVFileName2 = fileName2.empty()? NULL: strdup(fileName2.c_str());
//            FILE* mse_pFile2 = fopen (pYUVFileName2, "at");
//            mult = mult*curr_mu_i_j;
//            fprintf(mse_pFile2, "%f\t\t\t\t %f\n", curr_mu_i_j, mult);
//            fclose(mse_pFile2);
//        }
//        
//#endif
//    }
//    
//    // push the last item (mu(i-4, i-5))
//    Double curr_mu_i_j = distortion_in_sliding_window[last_frame_to_be_encoded-4] / (distortion_in_sliding_window[last_frame_to_be_encoded-5] + sigma_squared_in_sliding_window[last_frame_to_be_encoded-4]);
//    mu_ij.push_back(curr_mu_i_j);
//    
//    
//    //    cout << "pred = " << last_frame_to_be_encoded-4 << " ref " << last_frame_to_be_encoded-5 << endl;
//    
//    // Calculate epsilon_i
//    Int gop_sz = 4;
//    
//    // Reset all the epsilon array to 0 -- four epsilons you want to compute
//    epsilon_array.resize(gop_sz + 1);
//    std::fill(epsilon_array.begin(), epsilon_array.end(), 0);
//    
//    Double eps = 1.0;
//    Double multiplier = 1.0;
//    for(UInt j = 0; j < 4; j++)
//    {
//        eps += multiplier*mu_ij.at(j);
//        multiplier = mu_ij.at(j);
//    }
//    epsilon_array[0] = eps;
//    
//    
//    //    cout << "Empty the mu(i,j) to re-calculate based on my previous QP offset choice " << endl;
//    mu_ij.clear();
//    
//    return;
//}




// xCalculateMock
Void TEncGOP::xCalculateAddPSNRMock( TComPic* pcPic, TComPicYuv* pcPicD, const AccessUnit& accessUnit, Double dEncTime, const InputColourSpaceConversion conversion, const Bool printFrameMSE )
{
    Double  dPSNR[MAX_NUM_COMPONENT];
    
    for(Int i=0; i<MAX_NUM_COMPONENT; i++)
    {
        dPSNR[i]=0.0;
    }
    
    TComPicYuv cscd;
    if (conversion!=IPCOLOURSPACE_UNCHANGED)
    {
        cscd.create(pcPicD->getWidth(COMPONENT_Y), pcPicD->getHeight(COMPONENT_Y), pcPicD->getChromaFormat(), g_uiMaxCUWidth, g_uiMaxCUHeight, g_uiMaxCUDepth);
        TVideoIOYuv::ColourSpaceConvert(*pcPicD, cscd, conversion, g_bitDepth, false);
    }
    TComPicYuv &picd=(conversion==IPCOLOURSPACE_UNCHANGED)?*pcPicD : cscd;
    
    //===== calculate PSNR =====
    Double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
    for(Int chan=0; chan<pcPicD->getNumberValidComponents(); chan++)
    {
        const ComponentID ch=ComponentID(chan);
        const Pel*  pOrg    = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
        Pel*  pRec    = picd.getAddr(ch);
        const Int   iStride = pcPicD->getStride(ch);
        
        const Int   iWidth  = pcPicD->getWidth (ch) - (m_pcEncTop->getPad(0) >> pcPic->getComponentScaleX(ch));
        const Int   iHeight = pcPicD->getHeight(ch) - (m_pcEncTop->getPad(1) >> pcPic->getComponentScaleY(ch));
        
        Int   iSize   = iWidth*iHeight;
        
        UInt64 uiSSDtemp=0;
        for(Int y = 0; y < iHeight; y++ )
        {
            for(Int x = 0; x < iWidth; x++ )
            {
                Intermediate_Int iDiff = (Intermediate_Int)( pOrg[x] - pRec[x] );
                uiSSDtemp   += iDiff * iDiff;
            }
            pOrg += iStride;
            pRec += iStride;
        }
        const Int maxval = 255 << (g_bitDepth[toChannelType(ch)] - 8);
        const Double fRefValue = (Double) maxval * maxval * iSize;
        dPSNR[ch]         = ( uiSSDtemp ? 10.0 * log10( fRefValue / (Double)uiSSDtemp ) : 999.99 );
        MSEyuvframe[ch]   = (Double)uiSSDtemp/(iSize);
    }
    
    
    /* calculate the size of the access unit, excluding:
     *  - any AnnexB contributions (start_code_prefix, zero_byte, etc.,)
     *  - SEI NAL units
     */
    UInt numRBSPBytes = 0;
    for (AccessUnit::const_iterator it = accessUnit.begin(); it != accessUnit.end(); it++)
    {
        UInt numRBSPBytes_nal = UInt((*it)->m_nalUnitData.str().size());
#if VERBOSE_RATE
        printf("*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
#endif
        if ((*it)->m_nalUnitType != NAL_UNIT_PREFIX_SEI && (*it)->m_nalUnitType != NAL_UNIT_SUFFIX_SEI)
        {
            numRBSPBytes += numRBSPBytes_nal;
        }
        
//        cout << "numRBSP Bytes NO AddPSNR " << numRBSPBytes << ", str.size " << numRBSPBytes_nal << endl;
    }
    
    UInt uibits = numRBSPBytes * 8;
    
//    cout << pcPic->getPOC() << ") UUUUUUUUUU Bits and PSNRY and MSEY " << uibits << ", " << dPSNR[COMPONENT_Y] << ", " <<MSEyuvframe[COMPONENT_Y] << endl;
    
    // store the Rate, PSNRY of frame i in sliding window
    if(distortion_in_sliding_window.size() > progress_in_sliding_window)
    {
        rate_in_sliding_window[progress_in_sliding_window] = uibits;
        distortion_in_sliding_window[progress_in_sliding_window] = MSEyuvframe[COMPONENT_Y];
    }
    else
    {
        rate_in_sliding_window.push_back(uibits);
        distortion_in_sliding_window.push_back(MSEyuvframe[COMPONENT_Y]);
    }
    
    
//    rate_in_sliding_window.push_back(uibits);
//    distortion_in_sliding_window.push_back(MSEyuvframe[COMPONENT_Y]);
    
    cout << "TEncGOP: Progress in sliding window  " << progress_in_sliding_window << endl;
    
    // Update the progress in sliding window (XXX supposed to be circular, but will leave it like that for now)
    progress_in_sliding_window++;
    
    // Increment the window length by one
    sliding_window_length++;
    
    
    cscd.destroy();
}




// calculate Epsilon
Void TEncGOP::calculateCurrentEpsilon(TComPic *pcPic)
{
    static bool is_fst_frame = true;
    
    if(is_fst_frame)
    {
        cout << "Case Frame-0 will be ignored for now! " << endl;
        is_fst_frame = false;
        return;
    }
    
    Int curr_poc = pcPic->getPOC();
    
    
    cout << "Current POC is  " << curr_poc << endl;
    displayDAndSigmaSlidingWindowList(progress_in_sliding_window);
    
    // visit the past
//    UInt start_loop_from = progress_in_sliding_window - sliding_window_length;
    
    // Calculate mu(i, j)
    for(UInt i = 1; i < progress_in_sliding_window; i++)
    {
        // mu_pred_ref = Dpred / (Dref + sigma^2)
        Double curr_mu_i_j = distortion_in_sliding_window[i] / (distortion_in_sliding_window[i-1] + sigma_squared_in_sliding_window[i]);
        mu_ij.push_back(curr_mu_i_j);
        cout << "curr_mu_i_j for i_pred = " << i << ", j_ref = " << (i-1) << ", is: " << mu_ij.back() << endl;
    }
    
    // empty up the mu(i, j) -- Dynamic
    cout << "Empty the mu(i,j) to recalulate based on my previous QP offset choice " << endl;
    mu_ij.clear();
    
    return;
}


Void TEncGOP::xCalculateInterlacedAddPSNR( TComPic* pcPicOrgFirstField, TComPic* pcPicOrgSecondField,
                                          TComPicYuv* pcPicRecFirstField, TComPicYuv* pcPicRecSecondField,
                                          const AccessUnit& accessUnit, Double dEncTime, const InputColourSpaceConversion conversion, const Bool printFrameMSE )
{
    Double  dPSNR[MAX_NUM_COMPONENT];
    TComPic    *apcPicOrgFields[2]={pcPicOrgFirstField, pcPicOrgSecondField};
    TComPicYuv *apcPicRecFields[2]={pcPicRecFirstField, pcPicRecSecondField};
    
    for(Int i=0; i<MAX_NUM_COMPONENT; i++)
    {
        dPSNR[i]=0.0;
    }
    
    TComPicYuv cscd[2 /* first/second field */];
    if (conversion!=IPCOLOURSPACE_UNCHANGED)
    {
        for(UInt fieldNum=0; fieldNum<2; fieldNum++)
        {
            TComPicYuv &reconField=*(apcPicRecFields[fieldNum]);
            cscd[fieldNum].create(reconField.getWidth(COMPONENT_Y), reconField.getHeight(COMPONENT_Y), reconField.getChromaFormat(), g_uiMaxCUWidth, g_uiMaxCUHeight, g_uiMaxCUDepth);
            TVideoIOYuv::ColourSpaceConvert(reconField, cscd[fieldNum], conversion, g_bitDepth, false);
            apcPicRecFields[fieldNum]=cscd+fieldNum;
        }
    }
    
    //===== calculate PSNR =====
    Double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
    
    assert(apcPicRecFields[0]->getChromaFormat()==apcPicRecFields[1]->getChromaFormat());
    const UInt numValidComponents=apcPicRecFields[0]->getNumberValidComponents();
    
    for(Int chan=0; chan<numValidComponents; chan++)
    {
        const ComponentID ch=ComponentID(chan);
        assert(apcPicRecFields[0]->getWidth(ch)==apcPicRecFields[1]->getWidth(ch));
        assert(apcPicRecFields[0]->getHeight(ch)==apcPicRecFields[1]->getHeight(ch));
        
        UInt64 uiSSDtemp=0;
        const Int   iWidth  = apcPicRecFields[0]->getWidth (ch) - (m_pcEncTop->getPad(0) >> apcPicRecFields[0]->getComponentScaleX(ch));
        const Int   iHeight = apcPicRecFields[0]->getHeight(ch) - (m_pcEncTop->getPad(1) >> apcPicRecFields[0]->getComponentScaleY(ch));
        
        Int   iSize   = iWidth*iHeight;
        
        for(UInt fieldNum=0; fieldNum<2; fieldNum++)
        {
            TComPic *pcPic=apcPicOrgFields[fieldNum];
            TComPicYuv *pcPicD=apcPicRecFields[fieldNum];
            
            const Pel*  pOrg    = (conversion!=IPCOLOURSPACE_UNCHANGED) ? pcPic ->getPicYuvTrueOrg()->getAddr(ch) : pcPic ->getPicYuvOrg()->getAddr(ch);
            Pel*  pRec    = pcPicD->getAddr(ch);
            const Int   iStride = pcPicD->getStride(ch);
            
            
            for(Int y = 0; y < iHeight; y++ )
            {
                for(Int x = 0; x < iWidth; x++ )
                {
                    Intermediate_Int iDiff = (Intermediate_Int)( pOrg[x] - pRec[x] );
                    uiSSDtemp   += iDiff * iDiff;
                }
                pOrg += iStride;
                pRec += iStride;
            }
        }
        const Int maxval = 255 << (g_bitDepth[toChannelType(ch)] - 8);
        const Double fRefValue = (Double) maxval * maxval * iSize*2;
        dPSNR[ch]         = ( uiSSDtemp ? 10.0 * log10( fRefValue / (Double)uiSSDtemp ) : 999.99 );
        MSEyuvframe[ch]   = (Double)uiSSDtemp/(iSize*2);
    }
    
    UInt uibits = 0; // NOTE: RExt - the number of bits for the pair is not calculated here - instead the overall total is used elsewhere.
    
    //===== add PSNR =====
    m_gcAnalyzeAll_in.addResult (dPSNR, (Double)uibits, MSEyuvframe);
    
    printf("\n                                      Interlaced frame %d: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", pcPicOrgSecondField->getPOC()/2 , dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
    if (printFrameMSE)
    {
        printf(" [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
    }
    
    for(UInt fieldNum=0; fieldNum<2; fieldNum++)
    {
        cscd[fieldNum].destroy();
    }
}

/** Function for deciding the nal_unit_type.
 * \param pocCurr POC of the current picture
 * \returns the nal unit type of the picture
 * This function checks the configuration and returns the appropriate nal_unit_type for the picture.
 */
NalUnitType TEncGOP::getNalUnitType(Int pocCurr, Int lastIDR, Bool isField)
{
    if (pocCurr == 0)
    {
        return NAL_UNIT_CODED_SLICE_IDR_W_RADL;
    }
    
#if EFFICIENT_FIELD_IRAP
    if(isField && pocCurr == 1)
    {
        // to avoid the picture becoming an IRAP
        return NAL_UNIT_CODED_SLICE_TRAIL_R;
    }
#endif
    
#if ALLOW_RECOVERY_POINT_AS_RAP
    if(m_pcCfg->getDecodingRefreshType() != 3 && (pocCurr - isField) % m_pcCfg->getIntraPeriod() == 0)
#else
        if ((pocCurr - isField) % m_pcCfg->getIntraPeriod() == 0)
#endif
        {
            if (m_pcCfg->getDecodingRefreshType() == 1)
            {
                return NAL_UNIT_CODED_SLICE_CRA;
            }
            else if (m_pcCfg->getDecodingRefreshType() == 2)
            {
                return NAL_UNIT_CODED_SLICE_IDR_W_RADL;
            }
        }
    if(m_pocCRA>0)
    {
        if(pocCurr<m_pocCRA)
        {
            // All leading pictures are being marked as TFD pictures here since current encoder uses all
            // reference pictures while encoding leading pictures. An encoder can ensure that a leading
            // picture can be still decodable when random accessing to a CRA/CRANT/BLA/BLANT picture by
            // controlling the reference pictures used for encoding that leading picture. Such a leading
            // picture need not be marked as a TFD picture.
            return NAL_UNIT_CODED_SLICE_RASL_R;
        }
    }
    if (lastIDR>0)
    {
        if (pocCurr < lastIDR)
        {
            return NAL_UNIT_CODED_SLICE_RADL_R;
        }
    }
    return NAL_UNIT_CODED_SLICE_TRAIL_R;
}

Double TEncGOP::xCalculateRVM()
{
    Double dRVM = 0;
    
    if( m_pcCfg->getGOPSize() == 1 && m_pcCfg->getIntraPeriod() != 1 && m_pcCfg->getFramesToBeEncoded() > RVM_VCEGAM10_M * 2 )
    {
        // calculate RVM only for lowdelay configurations
        std::vector<Double> vRL , vB;
        size_t N = m_vRVM_RP.size();
        vRL.resize( N );
        vB.resize( N );
        
        Int i;
        Double dRavg = 0 , dBavg = 0;
        vB[RVM_VCEGAM10_M] = 0;
        for( i = RVM_VCEGAM10_M + 1 ; i < N - RVM_VCEGAM10_M + 1 ; i++ )
        {
            vRL[i] = 0;
            for( Int j = i - RVM_VCEGAM10_M ; j <= i + RVM_VCEGAM10_M - 1 ; j++ )
                vRL[i] += m_vRVM_RP[j];
            vRL[i] /= ( 2 * RVM_VCEGAM10_M );
            vB[i] = vB[i-1] + m_vRVM_RP[i] - vRL[i];
            dRavg += m_vRVM_RP[i];
            dBavg += vB[i];
        }
        
        dRavg /= ( N - 2 * RVM_VCEGAM10_M );
        dBavg /= ( N - 2 * RVM_VCEGAM10_M );
        
        Double dSigamB = 0;
        for( i = RVM_VCEGAM10_M + 1 ; i < N - RVM_VCEGAM10_M + 1 ; i++ )
        {
            Double tmp = vB[i] - dBavg;
            dSigamB += tmp * tmp;
        }
        dSigamB = sqrt( dSigamB / ( N - 2 * RVM_VCEGAM10_M ) );
        
        Double f = sqrt( 12.0 * ( RVM_VCEGAM10_M - 1 ) / ( RVM_VCEGAM10_M + 1 ) );
        
        dRVM = dSigamB / dRavg * f;
    }
    
    return( dRVM );
}

/** Attaches the input bitstream to the stream in the output NAL unit
 Updates rNalu to contain concatenated bitstream. rpcBitstreamRedirect is cleared at the end of this function call.
 *  \param codedSliceData contains the coded slice data (bitstream) to be concatenated to rNalu
 *  \param rNalu          target NAL unit
 */
Void TEncGOP::xAttachSliceDataToNalUnit (OutputNALUnit& rNalu, TComOutputBitstream*& codedSliceData)
{
    // Byte-align
    rNalu.m_Bitstream.writeByteAlignment();   // Slice header byte-alignment
    
    // Perform bitstream concatenation
    if (codedSliceData->getNumberOfWrittenBits() > 0)
    {
        rNalu.m_Bitstream.addSubstream(codedSliceData);
    }
    
    m_pcEntropyCoder->setBitstream(&rNalu.m_Bitstream);
    
    codedSliceData->clear();
}

// Function will arrange the long-term pictures in the decreasing order of poc_lsb_lt,
// and among the pictures with the same lsb, it arranges them in increasing delta_poc_msb_cycle_lt value
Void TEncGOP::arrangeLongtermPicturesInRPS(TComSlice *pcSlice, TComList<TComPic*>& rcListPic)
{
    TComReferencePictureSet *rps = pcSlice->getRPS();
    if(!rps->getNumberOfLongtermPictures())
    {
        return;
    }
    
    // Arrange long-term reference pictures in the correct order of LSB and MSB,
    // and assign values for pocLSBLT and MSB present flag
    Int longtermPicsPoc[MAX_NUM_REF_PICS], longtermPicsLSB[MAX_NUM_REF_PICS], indices[MAX_NUM_REF_PICS];
    Int longtermPicsMSB[MAX_NUM_REF_PICS];
    Bool mSBPresentFlag[MAX_NUM_REF_PICS];
    ::memset(longtermPicsPoc, 0, sizeof(longtermPicsPoc));    // Store POC values of LTRP
    ::memset(longtermPicsLSB, 0, sizeof(longtermPicsLSB));    // Store POC LSB values of LTRP
    ::memset(longtermPicsMSB, 0, sizeof(longtermPicsMSB));    // Store POC LSB values of LTRP
    ::memset(indices        , 0, sizeof(indices));            // Indices to aid in tracking sorted LTRPs
    ::memset(mSBPresentFlag , 0, sizeof(mSBPresentFlag));     // Indicate if MSB needs to be present
    
    // Get the long-term reference pictures
    Int offset = rps->getNumberOfNegativePictures() + rps->getNumberOfPositivePictures();
    Int i, ctr = 0;
    Int maxPicOrderCntLSB = 1 << pcSlice->getSPS()->getBitsForPOC();
    for(i = rps->getNumberOfPictures() - 1; i >= offset; i--, ctr++)
    {
        longtermPicsPoc[ctr] = rps->getPOC(i);                                  // LTRP POC
        longtermPicsLSB[ctr] = getLSB(longtermPicsPoc[ctr], maxPicOrderCntLSB); // LTRP POC LSB
        indices[ctr]      = i;
        longtermPicsMSB[ctr] = longtermPicsPoc[ctr] - longtermPicsLSB[ctr];
    }
    Int numLongPics = rps->getNumberOfLongtermPictures();
    assert(ctr == numLongPics);
    
    // Arrange pictures in decreasing order of MSB;
    for(i = 0; i < numLongPics; i++)
    {
        for(Int j = 0; j < numLongPics - 1; j++)
        {
            if(longtermPicsMSB[j] < longtermPicsMSB[j+1])
            {
                std::swap(longtermPicsPoc[j], longtermPicsPoc[j+1]);
                std::swap(longtermPicsLSB[j], longtermPicsLSB[j+1]);
                std::swap(longtermPicsMSB[j], longtermPicsMSB[j+1]);
                std::swap(indices[j]        , indices[j+1]        );
            }
        }
    }
    
    for(i = 0; i < numLongPics; i++)
    {
        // Check if MSB present flag should be enabled.
        // Check if the buffer contains any pictures that have the same LSB.
        TComList<TComPic*>::iterator  iterPic = rcListPic.begin();
        TComPic*                      pcPic;
        while ( iterPic != rcListPic.end() )
        {
            pcPic = *iterPic;
            if( (getLSB(pcPic->getPOC(), maxPicOrderCntLSB) == longtermPicsLSB[i])   &&     // Same LSB
               (pcPic->getSlice(0)->isReferenced())     &&    // Reference picture
               (pcPic->getPOC() != longtermPicsPoc[i])    )  // Not the LTRP itself
            {
                mSBPresentFlag[i] = true;
                break;
            }
            iterPic++;
        }
    }
    
    // tempArray for usedByCurr flag
    Bool tempArray[MAX_NUM_REF_PICS]; ::memset(tempArray, 0, sizeof(tempArray));
    for(i = 0; i < numLongPics; i++)
    {
        tempArray[i] = rps->getUsed(indices[i]);
    }
    // Now write the final values;
    ctr = 0;
    Int currMSB = 0, currLSB = 0;
    // currPicPoc = currMSB + currLSB
    currLSB = getLSB(pcSlice->getPOC(), maxPicOrderCntLSB);
    currMSB = pcSlice->getPOC() - currLSB;
    
    for(i = rps->getNumberOfPictures() - 1; i >= offset; i--, ctr++)
    {
        rps->setPOC                   (i, longtermPicsPoc[ctr]);
        rps->setDeltaPOC              (i, - pcSlice->getPOC() + longtermPicsPoc[ctr]);
        rps->setUsed                  (i, tempArray[ctr]);
        rps->setPocLSBLT              (i, longtermPicsLSB[ctr]);
        rps->setDeltaPocMSBCycleLT    (i, (currMSB - (longtermPicsPoc[ctr] - longtermPicsLSB[ctr])) / maxPicOrderCntLSB);
        rps->setDeltaPocMSBPresentFlag(i, mSBPresentFlag[ctr]);
        
        assert(rps->getDeltaPocMSBCycleLT(i) >= 0);   // Non-negative value
    }
    for(i = rps->getNumberOfPictures() - 1, ctr = 1; i >= offset; i--, ctr++)
    {
        for(Int j = rps->getNumberOfPictures() - 1 - ctr; j >= offset; j--)
        {
            // Here at the encoder we know that we have set the full POC value for the LTRPs, hence we
            // don't have to check the MSB present flag values for this constraint.
            assert( rps->getPOC(i) != rps->getPOC(j) ); // If assert fails, LTRP entry repeated in RPS!!!
        }
    }
}

/** Function for finding the position to insert the first of APS and non-nested BP, PT, DU info SEI messages.
 * \param accessUnit Access Unit of the current picture
 * This function finds the position to insert the first of APS and non-nested BP, PT, DU info SEI messages.
 */
Int TEncGOP::xGetFirstSeiLocation(AccessUnit &accessUnit)
{
    // Find the location of the first SEI message
    AccessUnit::iterator it;
    Int seiStartPos = 0;
    for(it = accessUnit.begin(); it != accessUnit.end(); it++, seiStartPos++)
    {
        if ((*it)->isSei() || (*it)->isVcl())
        {
            break;
        }
    }
    //  assert(it != accessUnit.end());  // Triggers with some legit configurations
    return seiStartPos;
}

Void TEncGOP::dblMetric( TComPic* pcPic, UInt uiNumSlices )
{
    TComPicYuv* pcPicYuvRec = pcPic->getPicYuvRec();
    Pel* Rec    = pcPicYuvRec->getAddr(COMPONENT_Y);
    Pel* tempRec = Rec;
    Int  stride = pcPicYuvRec->getStride(COMPONENT_Y);
    UInt log2maxTB = pcPic->getSlice(0)->getSPS()->getQuadtreeTULog2MaxSize();
    UInt maxTBsize = (1<<log2maxTB);
    const UInt minBlockArtSize = 8;
    const UInt picWidth = pcPicYuvRec->getWidth(COMPONENT_Y);
    const UInt picHeight = pcPicYuvRec->getHeight(COMPONENT_Y);
    const UInt noCol = (picWidth>>log2maxTB);
    const UInt noRows = (picHeight>>log2maxTB);
    assert(noCol > 1);
    assert(noRows > 1);
    UInt64 *colSAD = (UInt64*)malloc(noCol*sizeof(UInt64));
    UInt64 *rowSAD = (UInt64*)malloc(noRows*sizeof(UInt64));
    UInt colIdx = 0;
    UInt rowIdx = 0;
    Pel p0, p1, p2, q0, q1, q2;
    
    Int qp = pcPic->getSlice(0)->getSliceQp();
    Int bitdepthScale = 1 << (g_bitDepth[CHANNEL_TYPE_LUMA]-8);
    Int beta = TComLoopFilter::getBeta( qp ) * bitdepthScale;
    const Int thr2 = (beta>>2);
    const Int thr1 = 2*bitdepthScale;
    UInt a = 0;
    
    memset(colSAD, 0, noCol*sizeof(UInt64));
    memset(rowSAD, 0, noRows*sizeof(UInt64));
    
    if (maxTBsize > minBlockArtSize)
    {
        // Analyze vertical artifact edges
        for(Int c = maxTBsize; c < picWidth; c += maxTBsize)
        {
            for(Int r = 0; r < picHeight; r++)
            {
                p2 = Rec[c-3];
                p1 = Rec[c-2];
                p0 = Rec[c-1];
                q0 = Rec[c];
                q1 = Rec[c+1];
                q2 = Rec[c+2];
                a = ((abs(p2-(p1<<1)+p0)+abs(q0-(q1<<1)+q2))<<1);
                if ( thr1 < a && a < thr2)
                {
                    colSAD[colIdx] += abs(p0 - q0);
                }
                Rec += stride;
            }
            colIdx++;
            Rec = tempRec;
        }
        
        // Analyze horizontal artifact edges
        for(Int r = maxTBsize; r < picHeight; r += maxTBsize)
        {
            for(Int c = 0; c < picWidth; c++)
            {
                p2 = Rec[c + (r-3)*stride];
                p1 = Rec[c + (r-2)*stride];
                p0 = Rec[c + (r-1)*stride];
                q0 = Rec[c + r*stride];
                q1 = Rec[c + (r+1)*stride];
                q2 = Rec[c + (r+2)*stride];
                a = ((abs(p2-(p1<<1)+p0)+abs(q0-(q1<<1)+q2))<<1);
                if (thr1 < a && a < thr2)
                {
                    rowSAD[rowIdx] += abs(p0 - q0);
                }
            }
            rowIdx++;
        }
    }
    
    UInt64 colSADsum = 0;
    UInt64 rowSADsum = 0;
    for(Int c = 0; c < noCol-1; c++)
    {
        colSADsum += colSAD[c];
    }
    for(Int r = 0; r < noRows-1; r++)
    {
        rowSADsum += rowSAD[r];
    }
    
    colSADsum <<= 10;
    rowSADsum <<= 10;
    colSADsum /= (noCol-1);
    colSADsum /= picHeight;
    rowSADsum /= (noRows-1);
    rowSADsum /= picWidth;
    
    UInt64 avgSAD = ((colSADsum + rowSADsum)>>1);
    avgSAD >>= (g_bitDepth[CHANNEL_TYPE_LUMA]-8);
    
    if ( avgSAD > 2048 )
    {
        avgSAD >>= 9;
        Int offset = Clip3(2,6,(Int)avgSAD);
        for (Int i=0; i<uiNumSlices; i++)
        {
            pcPic->getSlice(i)->setDeblockingFilterOverrideFlag(true);
            pcPic->getSlice(i)->setDeblockingFilterDisable(false);
            pcPic->getSlice(i)->setDeblockingFilterBetaOffsetDiv2( offset );
            pcPic->getSlice(i)->setDeblockingFilterTcOffsetDiv2( offset );
        }
    }
    else
    {
        for (Int i=0; i<uiNumSlices; i++)
        {
            pcPic->getSlice(i)->setDeblockingFilterOverrideFlag(false);
            pcPic->getSlice(i)->setDeblockingFilterDisable(        pcPic->getSlice(i)->getPPS()->getPicDisableDeblockingFilterFlag() );
            pcPic->getSlice(i)->setDeblockingFilterBetaOffsetDiv2( pcPic->getSlice(i)->getPPS()->getDeblockingFilterBetaOffsetDiv2() );
            pcPic->getSlice(i)->setDeblockingFilterTcOffsetDiv2(   pcPic->getSlice(i)->getPPS()->getDeblockingFilterTcOffsetDiv2()   );
        }
    }
    
    free(colSAD);
    free(rowSAD);
}

// Dump reference utilization
Void TEncGOP::dumpReferenceUtilization()
{
//    m_pcSliceEncoder->reference_utitilization_rates[][]
    
    // Count how many rPOC = 0
     // - Open file with the sequence name and rpoc
     // - Write the sequence and r1, and r2, r3, r4
    
    // more than two frames are permitted
    if(g_FrameCount < 2)
    {
        return;
    }
    
    // cout << "Slice# " << pcSlice->getPOC() << ", Intra Count: " << pcSlice->intra_modes << endl;
    const UInt uiFrameWidth  = g_FrameWidth; // get the residual frame
    const UInt uiFrameHeight = g_FrameHeight; // get the residual frame
    const Double max_8x8_per_frame = ceil((1.0*uiFrameWidth * uiFrameHeight) / (8 * 8));
    
    // Count how many counts for this rPOC
    const Int remainder = (g_FrameCount-1) % 4;
    const Int division  = (g_FrameCount-1) / 4;
    
    for (Int rPOC = 0; rPOC < 4; ++rPOC)
    {
        Int frame_count_per_rPOC = (rPOC <= remainder)? (division+1): division;
        
        // Do not include Frame number 0
        if(rPOC == 0)
        {
            frame_count_per_rPOC--;
        }
        
        Double max_normalized_8x8 = (max_8x8_per_frame*frame_count_per_rPOC);
        Double percentage_1 = (frame_count_per_rPOC==0)? 0:100.0*m_pcSliceEncoder->reference_utitilization_rates[rPOC][0]
                            / (max_normalized_8x8);
        Double percentage_2 = (frame_count_per_rPOC==0)? 0:100.0*m_pcSliceEncoder->reference_utitilization_rates[rPOC][1]
                            / (max_normalized_8x8);
        Double percentage_3 = (frame_count_per_rPOC==0)? 0:100.0*m_pcSliceEncoder->reference_utitilization_rates[rPOC][2]
                            / (max_normalized_8x8);
        Double percentage_4 = (frame_count_per_rPOC==0)? 0:100.0*m_pcSliceEncoder->reference_utitilization_rates[rPOC][3]
                            / (max_normalized_8x8);
        
#if IS_DEBUG_CALC_INTERDEP_REF_UTILIZATION
        cout << "\nrPOC " << (rPOC) << endl;
        cout << "frame_count " << frame_count_per_rPOC << endl;
        cout << "8x8 blocks: " << max_8x8_per_frame  << " norm: " << max_normalized_8x8 << endl;
        cout << "c: "<< m_pcSliceEncoder->reference_utitilization_rates[rPOC][0] << " " << m_pcSliceEncoder->reference_utitilization_rates[rPOC][1] << " " << m_pcSliceEncoder->reference_utitilization_rates[rPOC][2] << " " << m_pcSliceEncoder->reference_utitilization_rates[rPOC][3] << endl;
        cout << "%: "<< percentage_1 << " " << percentage_2 << " " << percentage_3 << " " << percentage_4 << endl;
#endif
        
        // Open file with sequence name
        string fileName = "";
        std::ostringstream oss;
        Int relativePOC = rPOC==0? 4:rPOC;
        oss << "Gen//Seq-TXT//" << "rPOC-" << relativePOC << "_" << g_qpInit << ".txt";
        fileName = oss.str();
        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        
        // Once with QP
        FILE* sastre_pFile = fopen (pYUVFileName, "at");
        fprintf(sastre_pFile, "%s\t\t\t%f\t\t\t%f\t\t\t%f\t\t\t%f\n", g_input_FileName.c_str(), percentage_1,
                percentage_2, percentage_3, percentage_4);
        fclose(sastre_pFile);
        
        // twice without QP
        oss.clear(); oss.str("");
        oss << "Gen//Seq-TXT//" << "rPOC-" << relativePOC << ".txt";
        fileName = oss.str();
        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        sastre_pFile = fopen (pYUVFileName, "at");
        string write_name = g_input_FileName + "_" + std::to_string(g_qpInit);
        fprintf(sastre_pFile, "%s\t\t\t%f\t\t\t%f\t\t\t%f\t\t\t%f\n", write_name.c_str(), percentage_1,
                percentage_2, percentage_3, percentage_4);
        fclose(sastre_pFile);

    }
    
}
 
// Dump reference utilization helper: Dumps at poc and after it with a certain offset
Void TEncGOP::dumpReferenceUtilizationAccumulated()
{

    // more than two frames are permitted
    if(g_FrameCount < 2)
    {
        return;
    }
    
    // cout << "Slice# " << pcSlice->getPOC() << ", Intra Count: " << pcSlice->intra_modes << endl;
    Int end_loop = g_FrameCount-1;
    
    for(Int current_w8t_index = 1; current_w8t_index < end_loop; current_w8t_index++)
    {
        // you need to check for other refs
        Double w1 = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(current_w8t_index);
        Double w2 = m_pcSliceEncoder->reference2_utilization_rates_perFrame.at(current_w8t_index);
        
        // Open file with sequence name
        string fileName = "";
        std::ostringstream oss;
        oss << "Gen//Seq-TXT//" << g_input_FileName << "_Ref1" << "_" << g_qpInit << ".txt";
        fileName = oss.str();
        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        
        // Ref1 Weights
        FILE* sastre_pFile = fopen (pYUVFileName, "at");
        fprintf(sastre_pFile, "%f\n", w1/100.0);
        fclose(sastre_pFile);
        
        // Ref2 Weights
        oss.clear(); oss.str("");
        oss << "Gen//Seq-TXT//" << g_input_FileName << "_Ref2" << "_" << g_qpInit << ".txt";
        fileName = oss.str();
        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        sastre_pFile = fopen (pYUVFileName, "at");
        string write_name = g_input_FileName + "_" + std::to_string(g_qpInit);
        fprintf(sastre_pFile, "%f\n", w2/100.0);
        fclose(sastre_pFile);

        
            
    } // end for
    
}
    
    
// Dump reference utilization helper: Dumps at poc and after it with a certain offset
Void TEncGOP::dumpReferenceUtilizationAccumulatedHelper()
{
    
    // - Open file with the sequence name and weights --- Accumulation of weights
    // - Write the sequence and r1, and r2, r3, r4
//    cout << "Hello From Dump Reference Uitilization " << endl;
    
    // more than two frames are permitted
    if(g_FrameCount < 2)
    {
        return;
    }
    
    // cout << "Slice# " << pcSlice->getPOC() << ", Intra Count: " << pcSlice->intra_modes << endl;
    const UInt uiFrameWidth  = g_FrameWidth; // get the residual frame
    const UInt uiFrameHeight = g_FrameHeight; // get the residual frame
    const Double max_8x8_per_frame = ceil((1.0*uiFrameWidth * uiFrameHeight) / (8 * 8));
    
    // Count how many counts for this rPOC
    const Int remainder = (g_FrameCount-1) % 4;
    const Int division  = (g_FrameCount-1) / 4;
    
    Int test_pred_poc = 8;
    
//    for (Int rPOC = 0; rPOC < 4; ++rPOC)
//    {
//        Int frame_count_per_rPOC = (rPOC <= remainder)? (division+1): division;
    
        // Do not include Frame number 0
//        if(rPOC == 0)
//        {
//            frame_count_per_rPOC--;
//        }
   
    Double mult = 1;
    Int prop_len = 4;
//    Int end_loop = test_pred_poc + prop_len;
    Int end_loop = g_FrameCount-1;
    
    for(Int current_w8t_index = test_pred_poc; current_w8t_index < end_loop; current_w8t_index++)
    {
        // you need to check for other refs
        Double w1 = m_pcSliceEncoder->reference1_utilization_rates_perFrame.at(current_w8t_index);
    
        
        
#if IS_DEBUG_CALC_INTERDEP_REF_UTILIZATION
        if( current_w8t_index == test_pred_poc)
        {
            cout << "\nPOC " << (current_w8t_index) << endl;
            //        m_pcSliceEncoder->printReferenceUtitilization(test_pred_poc);
            
            // only when iOffset is 0
            for(Int j = 0; j < m_pcSliceEncoder->reference1_utilization_rates_perFrame.size(); j++)
            {
                m_pcSliceEncoder->printFrameReferenceUtitilization(j);
            }
            
        }
#endif
        
        // Open file with sequence name
        string fileName = "";
        std::ostringstream oss;
        oss << "Gen//Seq-TXT//" << g_input_FileName << "-Util-" << (test_pred_poc-1) << "_" << g_qpInit << ".txt";
        fileName = oss.str();
        Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
    
    
        
        // Once with weights only
        FILE* sastre_pFile = fopen (pYUVFileName, "at");
        fprintf(sastre_pFile, "%f\n", w1);
        fclose(sastre_pFile);
        
        // acccumulate
        mult *= w1/100.0;
        
        // twice without without weights
        oss.clear(); oss.str("");
        oss << "Gen//Seq-TXT//" << g_input_FileName << "-MulUtil-" << (test_pred_poc-1) << "_" << g_qpInit << ".txt";
        fileName = oss.str();
        pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
        sastre_pFile = fopen (pYUVFileName, "at");
        string write_name = g_input_FileName + "_" + std::to_string(g_qpInit);
        fprintf(sastre_pFile, "%f\n", mult);
        fclose(sastre_pFile);
        
    }
    
}
    
    
// Hossam: unused
Void TEncGOP::dumpReferenceUtilizationHelper(const Double * reference_counts, Int rPOC)
{
    
    // cout << "Slice# " << pcSlice->getPOC() << ", Intra Count: " << pcSlice->intra_modes << endl;
    const UInt uiFrameWidth  = g_FrameWidth; // get the residual frame
    const UInt uiFrameHeight = g_FrameHeight; // get the residual frame
    Double max_8x8_per_frame = ceil((1.0*uiFrameWidth * uiFrameHeight) / (8 * 8));

    // Count how many counts for this rPOC
    Int remainder = g_FrameCount % 4;
    Int division = g_FrameCount / 4;
    Int count = (remainder == rPOC)? division: (division + 1);
    
    
    Double percentage_1 = reference_counts[0] / (max_8x8_per_frame*count);
    Double percentage_2 = reference_counts[1] / (max_8x8_per_frame*count);
    Double percentage_3 = reference_counts[2] / (max_8x8_per_frame*count);
    Double percentage_4 = reference_counts[3] / (max_8x8_per_frame*count);
    
    
    // Open file with sequence name
    string fileName = "";
    std::ostringstream oss;
    oss << "Gen//Seq-TXT//" << "rPOC-" << rPOC  << "_" << g_qpInit << ".txt";
    fileName = oss.str();
    Char* pYUVFileName = fileName.empty()? NULL: strdup(fileName.c_str());
    FILE* sastre_pFile = fopen (pYUVFileName, "at");
    
    fprintf(sastre_pFile, "%s\t\t\t%f\t\t\t%f\t\t\t%f\t\t\t%f\n", g_input_FileName.c_str(), percentage_1,
            percentage_2, percentage_3, percentage_4);
    fclose(sastre_pFile);

}


//! \}
